---
title: "R para Ci√™ncia de Dados 2"
subtitle: "dplyr ++"
author: "<img src = 'https://d33wubrfki0l68.cloudfront.net/9b0699f18268059bdd2e5c21538a29eade7cbd2b/67e5c/img/logo/cursor1-5.png' width = '30%'>"
date: "`r paste(lubridate::month(Sys.Date(), label = TRUE, abbr = FALSE, locale = 'pt_BR.UTF-8'), 'de', lubridate::year(Sys.Date()))`"
output:
  xaringan::moon_reader:
    css: ["default", "default-fonts", "css/custom-intro.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: "4:3"
---

```{r setup, include=FALSE}
library(dplyr)

colorido <- function(x, cor = "#6495ed") {
  glue::glue(
    '<span style="color:{cor}; font-weight: bold;">{x}</span>'
  ) %>% 
    htmltools::HTML()
}

options(width = 80)
```

class: titulo
# Motiva√ß√£o

---
## Base do SINESP

Nos exemplos a seguir, vamos utilizar a base do Sistema Nacional de Informa√ß√µes de Seguran√ßa P√∫blica (SINESP).

Ela possui as seguintes vari√°veis:

- Nome do munic√≠pio: `munic√≠pio`

- UF (sliga): `sigla_uf`

- Regi√£o do Brasil: `regiao`

- M√™s/ano: `mes_ano`

- N√∫mero de v√≠timas: `vitima`

---
class: titulo
# O pacote dplyr

---
## Verbos principais

J√° vimos que com os principais verbos do `{dplyr}` j√° conseguimos fazer diversas opera√ß√µes de manipula√ß√£o de bases de dados.

.pull-left[
- Selecionar colunas: `select()`

- Ordenar linhas: `arrange()`

- Filtrar linhas: `filter()`

- Criar ou modificar colunas: `mutate()`

- Agrupar e sumarizar: `group_by()` + `summarise()`
]

.pull-right[
```{r, out.width="100%", echo = FALSE}
knitr::include_graphics("img/03-dplyr-plus/arte_dplyr.png")
```
]

<center>
`r colorido("Mas o dplyr tem muito mais para oferecer. MUITO MAIS!")`
</center>

---
## Miscel√¢nea de fun√ß√µes √∫teis

Para aquecer, vamos listar uma miscel√¢nea de fun√ß√µes muito √∫teis, mas menos conhecidas do `{dplyr}`.

- `bind_rows()` e `bind_cols()`

- `case_when()`

- `coalesce()`: para substituir os `NAs` de uma coluna pelos valores equivalentes de uma segunda coluna.

---
## bind_rows()

Vamos usar a fun√ß√£o `bind_rows()` para juntarmos duas bases com as mesmas colunas.

```{r}
# Juntando duas bases
imdb_2015 <- readr::read_rds("../data-raw/rds/imdb_por_ano/imdb_2015.rds")
imdb_2016 <- readr::read_rds("../data-raw/rds/imdb_por_ano/imdb_2016.rds")

bind_rows(imdb_2015, imdb_2016) %>% head()
```

---
##  

Neste caso, a fun√ß√£o `bind_rows()` √© equivalente √† fun√ß√£o `rbind()`.

```{r}
# Juntando duas bases
imdb_2015 <- readr::read_rds("../data-raw/rds/imdb_por_ano/imdb_2015.rds")
imdb_2016 <- readr::read_rds("../data-raw/rds/imdb_por_ano/imdb_2016.rds")

rbind(imdb_2015, imdb_2016) %>% head()
```

<br>

**Observa√ß√£o**: tanto para a `bind_rows()` quanto para a `rbind()`, a ordem das colunas em ambas as bases pode ser diferente. As colunas s√£o empilhadas pelo nome.

---
## 

Podemos tamb√©m usar a fun√ß√£o `bind_rows()` para juntar v√°rias tabelas. Aqui, todas as tabelas continuam tendo as mesmas colunas.

```{r}
arquivos <- list.files("../data-raw/rds/imdb_por_ano/", full.names = TRUE)

arquivos %>%
  purrr::map(readr::read_rds) %>%
  bind_rows() %>% 
  head()
```

**Observa√ß√£o**: a fun√ß√£o `purrr::map()` est√° aplicando a fun√ß√£o `readr::read_rds()` a todos os elementos do vetor `arquivos` e devolvendo uma lista de tibbles, uma para cada ano da base IMDB. Aprenderemos mais sobre essa fun√ß√£o na aula de `purrr`.

---
## 

Como a fun√ß√£o `map()` devolve uma lista, a fun√ß√£o `rbind()` n√£o funcionaria.

```{r}
arquivos <- list.files("../data-raw/rds/imdb_por_ano/", full.names = TRUE)

arquivos %>%
  purrr::map(readr::read_rds) %>%
  rbind()
```

---
## 

Al√©m disso, a fun√ß√£o `bind_rows()` pode ser utilizada para empilhar bases com colunas diferentes.

```{r}
tab1 <- tibble::tibble(
  var1 = c(1, 2, 3),
  var2 = c("a", "b", "c"),
  var3 = c(10, 20, 30)
)

tab2 <- tibble::tibble(
  var2 = c("d", "e", "f"),
  var1 = c(4, 5, 6)
)

bind_rows(tab1, tab2)
```

---
## 

Ao contr√°rio da fun√ß√£o `rbind()`.

```{r, error=TRUE}
tab1 <- tibble::tibble(
  var1 = c(1, 2, 3),
  var2 = c("a", "b", "c"),
  var3 = c(10, 20, 30)
)

tab2 <- tibble::tibble(
  var2 = c("d", "e", "f"),
  var1 = c(4, 5, 6)
)

rbind(tab1, tab2)
```


---
## coalesce()

No exemplo abaixo, substituimos os `NAs` da coluna `var1` pelos valores equivalentes da coluna `var2` (criamos uma nova coluna `var3` com o resultado para visualizarmos melhor). No caso em que as duas colunas apresentavam `NA`, a coluna `var3` continuou com o `NA`.

```{r}
tab <- tibble::tibble(
  var1 = c(1, 2, NA, 2, 10, NA, NA),
  var2 = c(NA, 2, 2, 10, 3, 0, NA)
)

tab %>%
  mutate(var3 = coalesce(var1, var2))
```

---
# Across

across() makes it possible to compute useful summaries that were previously impossible. For example, it‚Äôs now easy to summarise numeric vectors with one function, factors with another, and still compute the number of rows in each group:

  
```{r, eval = FALSE}

df %>%
  group_by(g1, g2) %>% 
  summarise(
    across(where(is.numeric), mean), 
    across(where(is.factor), nlevels),
    n = n(), 
  )
```
  
across() reduces the number of functions that dplyr needs to provide. This makes dplyr easier for you to use (because there are fewer functions to remember) and easier for us to develop (since we only need to implement one function for each new verb, not four).

With the where() helper, across() unifies _if and _at semantics, allowing combinations that used to be impossible. For example, you can now transform all numeric columns whose name begins with ‚Äúx‚Äù: across(where(is.numeric) & starts_with("x")).

across() doesn‚Äôt need vars(). The _at() functions are the only place in dplyr where you have to use vars(), which makes them unusual, and hence harder to learn and remember.


---
class: inverse, middle, center

# Pivotagem

---

# pivot_wider()

```{r}
knitr::include_graphics("img/03-dplyr-plus/wider.png")
```

(retirado do livro [r4ds](https://r4ds.had.co.nz))

---

# pivot_longer()

```{r}
knitr::include_graphics("img/03-dplyr-plus/longer.png")
```

(retirado do livro [r4ds](https://r4ds.had.co.nz))

---
class: center

# Vamos ao R!

```{r echo=FALSE, fig.align='center', out.width="80%"}
knitr::include_graphics("img/03-dplyr-plus/gato.gif")
```

<!-- Finalizando ----------------------------------------------------------- -->

---
class: inverse, middle, center

# Resumo

---

# Resumo

Hoje vimos alguns conceitos de

- Importa√ß√£o de dados com `{readxl}` e `{readr}`, e uma palhinha do `{purrr}`
- Os cinco verbos do `{dplyr}`
- Conex√£o com banco de dados e a fun√ß√£o `collect()`
- Pivotagem com as fun√ß√µes `pivot_wider()` e `pivot_longer()`

---

# Algumas refer√™ncias

- [Material de tidyverse da UFPR](http://www.leg.ufpr.br/~walmes/ensino/dsbd-linprog/slides/02-r-tidyverse.html#1)
- [Material da Curso-R](https://www.curso-r.com/material/)
- [Apresenta√ß√£o Garret Grolemund](https://github.com/rstudio/webinars/blob/master/05-Data-Wrangling-with-R-and-RStudio/wrangling-webinar.pdf)

---

### Joins com `{dplyr}`

--

Exemplos sem exerc√≠cio:

### `nest()`/`unnest()` com `{tidyr}`

### Fazendo fun√ß√µes que usam `dplyr` com `{{ }}`

---

# Bases de dados

Base do SINESP: Sistema Nacional de Informa√ß√µes de Seguran√ßa P√∫blica

- `munic√≠pio`
- `sigla_uf`
- `regiao`
- `mes_ano`
- `vitima`

--

Para o exerc√≠cio de joins, vamos considerar a base Estadual tamb√©m:

- `uf`
- `tipo_crime`
- `ano`
- `mes`
- `ocorrencias`

### As bases j√° est√£o no reposit√≥rio

---

# Taxonomia

## ‚Ü™Ô∏è `{pacote}`

--

## ‚Ü™Ô∏è `pacote::funcao()` ou `funcao()`

--

## ‚Ü™Ô∏è `da_` para bases de dados

<!-- Parte 1---------------------------------------------------------------- -->

---
class: inverse, middle, center

# separate() e unite()

---

# Revisando tidy data

√â uma base que une os conceitos da estat√≠stica (amostra, vari√°vel) e da inform√°tica (linhas, colunas)

### As observa√ß√µes est√£o nas linhas

### As vari√°veis est√£o nas colunas

### Os valores est√£o nas c√©lulas

---

# Motiva√ß√£o

- Muitas vezes nossas c√©lulas n√£o s√£o valores.
- Podemos querer juntar as categorias de duas vari√°veis em uma s√≥.
- Ou ent√£o separar as categorias de uma vari√°vel em v√°rias.
- Para isso usamos `tidyr::separate()` e `tidyr::unite()`

---

# Nota√ß√£o

### `unite()`

```{r eval=FALSE, echo=TRUE}
dados %>% 
  {{unite(coluna_nova, colunas, para, colar, sep = "separador")}}
```

### `separate()`


```{r eval=FALSE, echo=TRUE}
dados %>% 
  {{separate(coluna_velha, c("colunas", "novas"), sep = "separador")}}
```

---
class: center

# Vamos ao R!

```{r echo=FALSE, fig.align='center', out.width="80%"}
knitr::include_graphics("img/03-dplyr-plus/gato.gif")
```

<!-- Parte 2---------------------------------------------------------------- -->

---
class: inverse, middle, center

# Pivotagem

---

# Motiva√ß√£o

- Quando nossas linhas n√£o s√£o unidades obsevacionais ou nossas colunas n√£o s√£o vari√°veis, precisamos fazer pivotagem.
- √â similar √† pivotagem do Excel, mas mais completa.
- O ato de pivotar envolve "espalhar" ou "derreter" as informa√ß√µes de uma tabela.

---

# pivot_wider()

```{r, out.width="90%"}
knitr::include_graphics("img/03-dplyr-plus/wider.png")
```

(retirado do livro [r4ds](https://r4ds.had.co.nz))

---

# pivot_longer()

```{r, out.width="90%"}
knitr::include_graphics("img/03-dplyr-plus/longer.png")
```

(retirado do livro [r4ds](https://r4ds.had.co.nz))

---
class: center

# Vamos ao R!

```{r echo=FALSE, fig.align='center', out.width="80%"}
knitr::include_graphics("img/03-dplyr-plus/gato.gif")
```

---

# Observa√ß√£o

- `pivot_longer()` e `pivot_wider()` s√£o novas vers√µes das fun√ß√µes `spread()` e `gather()`, respectivamente.
- As fun√ß√µes foram refatoradas por conta de reiteradas reclama√ß√µes da comunidade sobre a dificuldade de ensinar essas fun√ß√µes.
- No entanto, as fun√ß√µes antigas n√£o deixaram de existir. Elas s√≥ deixar√£o de ser atualizadas. Uma fun√ß√£o assim √© chamada de "aposentada" (ver ?spread).
- `pivot_longer()` e `pivot_wider()` ainda est√£o em desenvolvimento e podem mudar no futuro.

<!-- Parte 3---------------------------------------------------------------- -->

---
class: inverse, middle, center

# Pausa


---
class: inverse, middle, center

# Joins

---

# Motiva√ß√£o

- Join √© o que precisamos fazer quando temos duas tabela e precisamos pegar a informa√ß√£o de uma a partir das vari√°veis de outra.
- A teoria de joins √© completamente desenvolvida dentro da √°rea de banco de dados.
- Claro que `{dplyr}` n√£o poderia nos deixar na m√£o para isso üòÉ 
- Melhor material: [livro r4ds](https://r4ds.had.co.nz/relational-data.html)

---
class: center

# Vamos ao R!

```{r echo=FALSE, fig.align='center', out.width="80%"}
knitr::include_graphics("img/03-dplyr-plus/gato.gif")
```

---

# Outros tipos de join

- `anti_join()`: mostra as linhas da base da esquerda que n√£o batem com a base da direita. √â √∫til para fazer de-paras. 
- `semi_join()`: √© parecido com `inner_join()`, mas n√£o copia as colunas da base da direita.

--

## Joins aproximados

- √â poss√≠vel fazer joins quando as vari√°veis n√£o batem exatamente, mas t√™m valores muito pr√≥ximos.
- Tamb√©m √© poss√≠vel fazer joins por similaridade de textos e at√© por express√µes regulares.
- D√™ uma olhada no pacote `{fuzzyjoin}`!

<!-- Parte 4---------------------------------------------------------------- -->

---
class: inverse, middle, center

# nest() / unnest()

---

# Motiva√ß√£o

- Nem sempre queremos trabalhar com valores nas c√©lulas
- √Äs vezes, pode ser √∫til guardar, em cada elemento, uma outra base de dados.
- Tabelas aninhadas podem facilitar visualiza√ß√£o e diminuem a quantidade de tabelas a serem consideradas no estudo.

--

- O tema √© pol√™mico e nem todos concordam...

---
class: center

# Vamos ao R!

```{r echo=FALSE, fig.align='center', out.width="80%"}
knitr::include_graphics("img/03-dplyr-plus/gato.gif")
```

<!-- Parte 5---------------------------------------------------------------- -->

---
class: inverse, middle, center

# Programando com dplyr

---

# Motiva√ß√£o

- O `{dplyr}` facilita a nossa vida ao permitir colocar os nomes das vari√°veis sem aspas nos argumentos das fun√ß√µes principais.
- Isso s√≥ √© poss√≠vel por conta de um recurso quase exclusivo do R, chamado de *non standard evaluation* (NSE).
- No entanto, quando queremos criar fun√ß√µes, isso pode atrapalhar

```{r eval=FALSE, echo=TRUE}
selecionar <- function(da, coluna) {
  da %>% 
    select(coluna)
}

da_sinesp_muni %>% 
  selecionar(regiao)
```
    
    #> Error: object 'regiao' not found

---

# Programando com R

- Para isso, existe o curly-curly `{{ }}`
- Basta coloc√°-lo ao redor do argumento que voc√™ quer passar

```{r eval=FALSE, echo=TRUE}
selecionar <- function(da, coluna) {
  da %>% 
    select({{coluna}})
}

da_sinesp_muni %>% 
  selecionar(regiao)
```

    # A tibble: 124,246 x 1
       regiao
       <chr> 
     1 NORTE 
     2 NORTE 
     3 NORTE 
     4 NORTE 
     5 NORTE 
     6 NORTE 
     7 NORTE 
     8 NORTE 
     9 NORTE 
    10 NORTE 
    # ‚Ä¶ with 124,236 more rows

---
class: center

# Vamos ao R!

```{r echo=FALSE, fig.align='center', out.width="80%"}
knitr::include_graphics("img/03-dplyr-plus/gato.gif")
```

---

# Resumindo

- Use `{{variavel}}` quando n√£o quiser colocar aspas no argumento da fun√ß√£o.
- Use `.data[["variavel"]]` quando quiser colocar aspas no argumento da fun√ß√£o.
- Use `{{nome}} := ...` quando quiser criar colunas com nomes que est√£o no argumento da fun√ß√£o.

--

__Refer√™ncia__: https://www.curso-r.com/blog/2019-08-21-nse/

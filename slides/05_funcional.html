<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R para Ciência de Dados 2</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="css/xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# R para Ciência de Dados 2
]
.subtitle[
## Programação funcional
]
.author[
### <img src = 'https://d33wubrfki0l68.cloudfront.net/9b0699f18268059bdd2e5c21538a29eade7cbd2b/67e5c/img/logo/cursor1-5.png' width = '30%'>
]

---




class: middle, center
# Iniciar gravação!

---
class: middle, center, inverse
# Listas

---
# Motivação

Listas são uma das estruturas de dados mais fundamentais do R. Na verdade, data
frames não passam de listas bonitinhas! Entender como elas funcionam vai nos
ajudar a entender melhor como o R trabalha por trás dos panos.

Já aprendemos muito sobre vetores e listas são apenas uma generalização desse
conceito. Nosso objetivo é saber usar ambos com a mesma facilidade, pois assim
também teremos mais uma ferramenta no nosso arsenal.

Listas, além de tudo isso, têm um papel central no pacote purrr e na programação
funcional dentro do R; não faz sentido falarmos do `map()` sem antes entender a
sua saída. Grande parte das funções do purrr existem para manipular listas,
convertê-las para vetores e vice-versa.

O que então faz com que as listas sejam tão especiais? O que as diferencia dos
vetores e porque não podemos usar uma só estrutura de dados para tudo? Vamos
começar do começo: como criar uma lista.

---
# list()

Para criar uma lista basta usar a função `list()`. Cada elemento ganha um
**índice** (entre colchetes duplos) e um **valor** (logo abaixo do índice).

.pull-left[


```r
list(1, 2, 3)
```

```
#&gt; [[1]]
#&gt; [1] 1
#&gt; 
#&gt; [[2]]
#&gt; [1] 2
#&gt; 
#&gt; [[3]]
#&gt; [1] 3
```

]

.pull-right[

Como listas costumam ficar longas, usar a função `str()` pode facilitar a
leitura da saída.


```r
str(list(1, 2, 3, 4))
```

```
#&gt; List of 4
#&gt;  $ : num 1
#&gt;  $ : num 2
#&gt;  $ : num 3
#&gt;  $ : num 4
```

]

---
# Listas nomeadas

Se não declararmos nada, os índices dos elementos são sempre numéricos como no
slide anterior. Uma alternativa é dar nomes para os elementos, assim os índices
ficam mais descritivos.


```r
list(um = 1, dois = 2, tres = 3)
```

```
#&gt; $um
#&gt; [1] 1
#&gt; 
#&gt; $dois
#&gt; [1] 2
#&gt; 
#&gt; $tres
#&gt; [1] 3
```

Neste caso, ao invés de `[[]]`, os nomes dos elementos são precedidos por um
`$`.

---
# Heterogeneidade: tipos

.pull-left[

Vetores no R são homogêneos, ou seja, só aceitam um tipo de dado. Se tentarmos
juntar vários tipos, eles são convertidos para ficarem uniformes.


```r
c(TRUE, 123, "ABC")
```

```
#&gt; [1] "TRUE" "123"  "ABC"
```

Esse processo é conhecido como **coerção** e, no geral, não queremos que isso
aconteça.

]

.pull-right[

Listas, por sua vez, são **heterogêneas**: elas aceitam qualquer tipo de dado!
Podemos misturar tudo à vontade sem nos preocupar com coerção.


```r
list(TRUE, 123, "ABC")
```

```
#&gt; [[1]]
#&gt; [1] TRUE
#&gt; 
#&gt; [[2]]
#&gt; [1] 123
#&gt; 
#&gt; [[3]]
#&gt; [1] "ABC"
```

]

---
# Heterogeneidade: comprimentos

Além de misturar tipos, podemos misturar elementos de diferentes comprimentos.
Uma lista pode conter vetores e até sub-listas!


```r
str(list(
  objeto = "abc",
  vetor = c(1, 2, 3),
  lista = list(TRUE, FALSE)
))
```

```
#&gt; List of 3
#&gt;  $ objeto: chr "abc"
#&gt;  $ vetor : num [1:3] 1 2 3
#&gt;  $ lista :List of 2
#&gt;   ..$ : logi TRUE
#&gt;   ..$ : logi FALSE
```

---
# Indexação

Acessar elementos de listas é um pouco mais complicado do que vetores. A base é
a mesma: `[i]` retorna a `i`-ésima posição. O problema é que, nas listas, existe
uma diferença entre a **posição** de um elemento e o **elemento** em si.

A `i`-ésima posição, em uma lista, sempre é uma **sub-lista**. Para pegar o
`i`-ésimo elemento, precisamos usar `[[i]]`! Alternativamente, em listas
nomeadas, podemos usar `["nome"]` e `[["nome"]]` (equivalente a `$nome`).

Os slides a seguir mostram várias maneiras de acessar os elementos e posições da
lista `l`, idêntica à do slide anterior.


```r
l &lt;- list(
  objeto = "abc",
  vetor = c(1, 2, 3),
  lista = list(TRUE, FALSE)
)
```

---
# Indexação: rua completa

Vamos pensar em listas como ruas. Quando usarmos `[i]` obteremos um trecho da
rua e quando usarmos `[[i]]` obteremos a família da casa correspondente.

Seguindo a lógica da metáfora, um vetor é uma casa com vários moradores e uma
sub-lista é uma vila.

&lt;img src="img/05_funcional/l.png" width="2560" /&gt;

---
# Indexação: casa 1


```r
l[1]
l["objeto"]
```

&lt;img src="img/05_funcional/l[1].png" width="2560" /&gt;

---
# Indexação: casas 2 e 3


```r
l[2:3]
l[c("vetor", "lista")]
l[-1]
```

&lt;img src="img/05_funcional/l[-1].png" width="2560" /&gt;

---
# Indexação: família da casa 1


```r
l[[1]]
l[["objeto"]]
l$objeto
```

&lt;img src="img/05_funcional/l[[1]].png" width="2560" /&gt;

---
# Indexação: família da casa 2


```r
l[[2]]
l[["vetor"]]
l$vetor
```

&lt;img src="img/05_funcional/l[[2]].png" width="2560" /&gt;

---
# Indexação: vila


```r
l[[3]]
l[["lista"]]
l$lista
```

&lt;img src="img/05_funcional/l[[3]].png" width="2560" /&gt;

---
# Indexação: casa 1 da vila


```r
l[[3]][1]
l[["lista"]][1]
l$lista[1]
```

&lt;img src="img/05_funcional/l[[3]][1].png" width="2560" /&gt;

---
# Indexação: família da casa 1 da vila


```r
l[[3]][[1]]
l[["lista"]][[1]]
l$lista[[1]]
```

&lt;img src="img/05_funcional/l[[3]][[1]].png" width="2560" /&gt;

---
# Rodada bônus!

Data frames são um tipo especial de lista e por isso podemos usar o `$` para
acessar colunas. A única restrição é que os elementos precisam ter o mesmo
tamanho.


```r
library(tidyverse)
as_tibble(list(
  col1 = c("a", "b"),
  col2 = c(1, 2),
  col3 = c(TRUE, FALSE),
  col4 = list(c(1, 3), 2) # list-column!
))
```

```
#&gt; # A tibble: 2 × 4
#&gt;   col1   col2 col3  col4     
#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;list&gt;   
#&gt; 1 a         1 TRUE  &lt;dbl [2]&gt;
#&gt; 2 b         2 FALSE &lt;dbl [1]&gt;
```

---
class: middle, center, inverse
# purrr

---
# Motivação

O objetivo do pacote purrr é trazer programação funcional (PF) para o R de forma
consistente. PF, como sugere o nome, gira em torno de funções: a maior parte das
funções recebe outras funções como entrada.

O purrr também lida com iterações, simplificando muito o processo que vimos aula
passada. Se planejarmos bem nossas funções, quase nunca mais precisaremos pensar
em `for`s ou `while`s.

Por fim, a estrutura de dados base do purrr é a lista. Por padrão, quase todas
as funções dele aceitam listas como entrada e retornam listas como saída. A
importância da primeira parte da aula vai ficar evidente a partir de agora.

No limite, a sintaxe do purrr é capaz de mudar para sempre o modo como
programamos, ensinando padrões robustos de programação (sem efeitos colaterais e
sem repetição de código). Mas como isso é possível? Vamos começar simplificando
o que vimos na seção anterior...

---
# Simplificando indexação

A primeira utilidade do purrr já aparece na indexação de listas. Ao invés de
usar colchetes duplos, podemos simplesmente usar a função `pluck()`.


```r
pluck(l, 3, 2) # Equivale a l[[3]][[2]]
```

```
#&gt; [1] FALSE
```

A dupla `keep_at()` / `discard_at()` filtra listas. Ambas recebem um vetor de
nomes ou posições e mantém / descartam os elementos daqueles índices.


```r
keep_at(l, c("objeto")) # Equivale a l[c("objeto")]
```

```
#&gt; $objeto
#&gt; [1] "abc"
```

Agora vamos falar da parte legal do pacote...

---
class: middle, center

&lt;img src="img/05_funcional/purrr.png" width="92%" style="display: block; margin: auto;" /&gt;

[Ilustração por @allison_horst](https://twitter.com/allison_horst)

---
# O pacote purrr

A funcionalidade que mais vamos usar do purrr é simplificar loops `for` e
`while`. Vamos analisar o loop a seguir para tentar entender quais são as
estruturas importantes.


```r
comprimentos &lt;- c()
for (i in seq_along(l)) {
  comprimentos[i] &lt;- length(l[[i]])
}
comprimentos
```

```
#&gt; [1] 1 3 2
```

Notem como só existem dois elementos principais: um **entrada** (a lista `l`) e
uma **função** sendo aplicada em cada elemento da entrada (`length()`). O vetor
intermediário `comprimentos` é só uma distração, pois ele só guarda resultados.

---
# map()

A função `map()` tem dois argumentos: uma entrada e o nome de uma função. A
função será aplicada em cada elemento do vetor ou da lista de entrada.


```r
map(l, length)
```

```
#&gt; $objeto
#&gt; [1] 1
#&gt; 
#&gt; $vetor
#&gt; [1] 3
#&gt; 
#&gt; $lista
#&gt; [1] 2
```

Se a entrada for uma lista nomeada, esses nomes serão preservados na saída.

---
# map(): função

A função que a `map()` recebe deve precisar de apenas 1 argumento. A função em
si pode receber vários argumentos, mas só o primeiro deve ser obrigatório.


```r
longo &lt;- function(elemento, limite = 1) {
  length(elemento) &gt; limite
}
map(l, longo)
```

```
#&gt; $objeto
#&gt; [1] FALSE
#&gt; 
#&gt; $vetor
#&gt; [1] TRUE
#&gt; 
#&gt; $lista
#&gt; [1] TRUE
```

---
# map(): saída

Como deve ter dado para reparar, a `map()` sempre retorna uma lista. Isso
acontece porque ela não sabe o que a sua função vai retornar, então um vetor
pode nem sempre funcionar.

.pull-left[


```r
media &lt;- function(x) {
  if (!is.numeric(x)) {
    return("Erro")
  }
  mean(x)
}
```

A função média retorna uma string se a entrada não for numérica e um número caso
contrário.

]

.pull-right[


```r
map(l, media)
```

```
#&gt; $objeto
#&gt; [1] "Erro"
#&gt; 
#&gt; $vetor
#&gt; [1] 2
#&gt; 
#&gt; $lista
#&gt; [1] "Erro"
```

]

---
# Achatamento

Se não quisermos uma lista de saída e tivermos _certeza_ que nossa função sempre
retorna objetos do mesmo tipo, podemos usar a `map_vec()`. Ela faz o máximo
possível para garantir que a saída seja um vetor.


```r
nums &lt;- list(1:2, 1:3, 1:4)
map_vec(nums, length)
```

```
#&gt; [1] 2 3 4
```

Alternativamente podemos usar a `list_c()`, que achata uma lista qualquer sem
precisar de uma função para ser aplicada.


```r
list_c(nums)
```

```
#&gt; [1] 1 2 1 2 3 1 2 3 4
```

---
# Achatamento: data frames

Uma operação comum é ler um vetor de arquivos com a `map()`. Se fizermos isso e
a saída da leitura for uma data frame, podemos empilhá-las com `list_rbind()`.


```r
c("../dados/imdb_2015.csv", "../dados/imdb_2016.csv") |&gt;
  map(read_csv) |&gt;
  list_rbind() |&gt;
  select(1:4) |&gt;                    # Reduzir saída
  filter(str_detect(titulo, "War")) # Reduzir saída
```

```
#&gt; # A tibble: 4 × 4
#&gt;   titulo                       ano diretor               duracao
#&gt;   &lt;chr&gt;                      &lt;dbl&gt; &lt;chr&gt;                   &lt;dbl&gt;
#&gt; 1 Shooting the Warwicks       2015 Adam Rifkin                95
#&gt; 2 Captain America: Civil War  2016 Anthony Russo             147
#&gt; 3 Warcraft                    2016 Duncan Jones              123
#&gt; 4 The Huntsman: Winter's War  2016 Cedric Nicolas-Troyan     120
```

---
# map2()

Se tivermos 2 vetores ou listas do mesmo comprimento e uma função que recebe 2
argumentos, podemos usar a `map2()` (ou `map2_vec()`) para iterar em ambos.


```r
comprimento &lt;- function(x, nome) {
  str_c(nome, " tem ", length(x), " elemento(s)")
}
map2(l, names(l), comprimento)
```

```
#&gt; $objeto
#&gt; [1] "objeto tem 1 elemento(s)"
#&gt; 
#&gt; $vetor
#&gt; [1] "vetor tem 3 elemento(s)"
#&gt; 
#&gt; $lista
#&gt; [1] "lista tem 2 elemento(s)"
```

---
# pmap()

A generalização do par `map2()` / `map2_vec()` é o par `pmap()` / `pmap_vec()`.
Neste caso, passamos uma lista com todas as entradas que vão para a função.


```r
tipo &lt;- function(x, classe, nome) {
  str_c(nome, " é ", classe, " (tamanho ", length(x), ")")
}
pmap(list(l, map(l, class), names(l)), tipo)
```

```
#&gt; $objeto
#&gt; [1] "objeto é character (tamanho 1)"
#&gt; 
#&gt; $vetor
#&gt; [1] "vetor é numeric (tamanho 3)"
#&gt; 
#&gt; $lista
#&gt; [1] "lista é list (tamanho 2)"
```

---
# Funções anônimas

Uma coisa que começa a incomodar é sempre ter que declarar uma função do lado de
fora da `map()`. Se nossa função tiver apenas uma linha, podemos usar a notação
de **função anônima**: `\()`.

Uma função anônima não precisa de um nome, então podemos declará-la diretamente
dentro de uma chamada. Isso funciona com qualquer função que recebe o nome de
outra função como argumento!


```r
map2_vec(
  list(1:2, 1:3, 1:4),
  c(3, 2, 6),
  \(vec, lim) length(vec) &gt; lim
)
```

```
#&gt; [1] FALSE  TRUE FALSE
```

---
# List-columns

Como vimos rapidamente na seção anterior, data frames aceitam listas como
colunas, as **list-columns**. A lista em si precisa ter o mesmo comprimento da
tabela, mas os seus elementos não estão sob a mesma restrição.


```r
df &lt;- tibble(
  nome = c("Bacon", "Dexter", "Zip"),
  cor = list(c("branco", "marrom"), "caramelo", "branco")
)
df
```

```
#&gt; # A tibble: 3 × 2
#&gt;   nome   cor      
#&gt;   &lt;chr&gt;  &lt;list&gt;   
#&gt; 1 Bacon  &lt;chr [2]&gt;
#&gt; 2 Dexter &lt;chr [1]&gt;
#&gt; 3 Zip    &lt;chr [1]&gt;
```

---
# List-columns: map()

Um dos jeitos mais simples de criar uma list-column é com o resultado de uma
`map()`. Imagine que queremos fazer uma operação que retorne vários elementos
para cada linha da tabela:


```r
df |&gt;
  mutate(frase = map2(nome, cor, \(n, c) str_c(n, " é ", c)))
```

```
#&gt; # A tibble: 3 × 3
#&gt;   nome   cor       frase    
#&gt;   &lt;chr&gt;  &lt;list&gt;    &lt;list&gt;   
#&gt; 1 Bacon  &lt;chr [2]&gt; &lt;chr [2]&gt;
#&gt; 2 Dexter &lt;chr [1]&gt; &lt;chr [1]&gt;
#&gt; 3 Zip    &lt;chr [1]&gt; &lt;chr [1]&gt;
```

Apesar de a `str_c()` ser vetorizada, ela não funciona se cada elemento tem
tamanhos diferentes.

---
# List-columns: unnest()

A função `unnest()` do tidyr é perfeita para expandir list-columns em colunas
normais. Passamos um vetor com colunas que tenham a mesma estrutura e a tabela
ganha mais linhas.


```r
df |&gt;
  mutate(frase = map2(nome, cor, \(n, c) str_c(n, " é ", c))) |&gt;
  unnest(c(cor, frase))
```

```
#&gt; # A tibble: 4 × 3
#&gt;   nome   cor      frase            
#&gt;   &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;            
#&gt; 1 Bacon  branco   Bacon é branco   
#&gt; 2 Bacon  marrom   Bacon é marrom   
#&gt; 3 Dexter caramelo Dexter é caramelo
#&gt; 4 Zip    branco   Zip é branco
```

---
# List-columns: nest()

Às vezes queremos também fazer a operação contrária. Agrupando por `.by`, a
função `nest()` cria uma list-column com todas as colunas que quisermos.


```r
df |&gt;
  mutate(frase = map2(nome, cor, \(n, c) str_c(n, " é ", c))) |&gt;
  unnest(c(cor, frase)) |&gt;
  nest(info = c(cor, frase), .by = nome)
```

```
#&gt; # A tibble: 3 × 2
#&gt;   nome   info            
#&gt;   &lt;chr&gt;  &lt;list&gt;          
#&gt; 1 Bacon  &lt;tibble [2 × 2]&gt;
#&gt; 2 Dexter &lt;tibble [1 × 2]&gt;
#&gt; 3 Zip    &lt;tibble [1 × 2]&gt;
```

Note como aqui o resultado é uma coluna de **sub-tabelas**!

---
# Rodada bônus!

Até pouco tempo atrás, a notação `\()` não existia. Se vocês virem código
antigos, pode ser que eles usem a notação `~`.


```r
\(arg1, arg2) sum(is.na(arg1), is.na(arg2)) # Notação nova
~ sum(is.na(.x), is.na(.y))                 # Notação antiga
```

Apesar de mais compacta, a notação antiga não permite escolher o nome dos
argumentos (o primeiro é sempre `.x`, o segundo `.y`, etc.). Ela também só
funcionava nas funções do tidyverse, então não podíamos usá-la sempre; a `\()`,
por exemplo, funciona em pipelines:


```r
df |&gt;
  { \(tabela) c(nrow(tabela), ncol(tabela)) }()
```

```
#&gt; [1] 3 2
```

---
class: middle, center, inverse
# Fim
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>

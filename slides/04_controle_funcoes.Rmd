---
title: "R para Ci√™ncia de Dados 2"
subtitle: "Controle de fluxo e fun√ß√µes"
author: "<img src = 'https://d33wubrfki0l68.cloudfront.net/9b0699f18268059bdd2e5c21538a29eade7cbd2b/67e5c/img/logo/cursor1-5.png' width = '30%'>"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: "css/xaringan-themer.css"
    nature:
      ratio: '16:9'
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(comment = "#>")
options(dplyr.print_min = 5, dplyr.print_max = 5, dplyr.width = 70)
```

class: middle, center
# Iniciar grava√ß√£o!

---
class: middle, center, inverse
# Controle de fluxo

---
# Motiva√ß√£o

J√° aprendemos muito sobre o R at√© agora e sabemos fazer coisas realmente
incr√≠veis com os pacotes que vimos. Mas ainda n√£o falamos (formalmente) sobre um
dos aspectos mais fundamentais da programa√ß√£o: controle de fluxo.

Controle de fluxo √© o termo usado para descrever as instru√ß√µes que nos permitem
controlar a ordem de execu√ß√£o do c√≥digo. Normalmente elas s√£o divididas em
**condicionais** (`if`, `else`) e **loops** (`while`, `for`), pois assim fica
mais f√°cil de entender a utilidade de cada instru√ß√£o.

Apesar da sua import√¢ncia, esse conceito nem sempre √© necess√°rio para fazer uma
an√°lise de dados, por isso esperamos tanto para aprender mais sobre ele. Na
pr√°tica, j√° usamos muito controle de fluxo neste curso, s√≥ nunca t√£o
explicitamente quanto hoje.

Mas por que ter√≠amos interesse em mudar a ordem de execu√ß√£o do c√≥digo? At√©
agora, "de cima para baixo" serviu para tudo que precis√°vamos... Qual √© a
utilidade do controle de fluxo?

---
# Ordem de execu√ß√£o

O que fazer se quisermos executar um certo c√≥digo somente se uma condi√ß√£o for
atendida? No exemplo abaixo, s√≥ podemos fazer a multiplica√ß√£o de `x` for
num√©rico.

```{r}
x <- 10
x * 2
```

Se `x` puder assumir outro tipo de valor, a multiplica√ß√£o n√£o far√° sentido e ir√°
retornar um erro. Neste caso, o ideal seria "pular" a multiplica√ß√£o.

```{r, error = TRUE}
x <- "dez"
x * 2
```

---
# if

A instru√ß√£o que nos permite executar comandos **condicionalmente** se chama
`if`.

> _**Se** `x` for num√©rico, multiplic√°-lo por 2._

```{r}
x <- 10
if (is.numeric(x)) {
  x * 2
}
```

```{r}
x <- "dez"
if (is.numeric(x)) {
  x * 2 # N√£o executa
}
```

---
# Anatomia do if

O `if` √© sempre acompanhado de par√™nteses com uma **condi√ß√£o** (mais sobre isso
no pr√≥ximo slide) e um par de chaves com um **corpo**, ou seja, todos os
comandos a serem executados caso a condi√ß√£o seja verdadeira.

```{r, eval = FALSE}
if (CONDICAO) {
  COMANDO_1
  COMANDO_2
  COMANDO_3
  # Resto do corpo...
}
```

N√£o h√° nenhuma restri√ß√£o sobre o que pode ir dentro do corpo de um `if`;
qualquer c√≥digo R v√°lido pode ser colocado l√° dentro, inclusive outros `if`s.

Antes de prosseguir, precisamos entender exatamente o que conta como condi√ß√£o e
como podemos criar condi√ß√µes mais complexas do que `is.numeric()`.

---
# Condi√ß√µes

As condi√ß√µes do `if` est√£o intimamente ligadas aos valores l√≥gicos do R: `TRUE`
e `FALSE`. Um `if` precisa que a express√£o entre par√™nteses retorne um √∫nico
valor l√≥gico, sen√£o ele n√£o sabe se deve executar o corpo ou n√£o.

```{r}
x <- 10
is.numeric(x)
```

Existem in√∫meras outras fun√ß√µes do R que retornam l√≥gicos (chamadas
**predicados**): `is.na()`, `is.character()`, `is.Date()`, `is.factor()`,
`is.list()`, etc.

```{r}
is.character(x)
```

---
# Condi√ß√µes: compara√ß√µes

J√° falamos sobre compara√ß√µes no _R para Ci√™ncia de Dados I_, ent√£o basta s√≥
dizer que todas retornam valores l√≥gicos que podem ser usados no `if`.

.pull-left[

```{r}
1 == 1 # Igual
2 > 2 # Maior
3 < 3 # Menor
```

]

.pull-right[

```{r}
1 != 1 # Diferente
2 >= 2 # Maior ou igual
3 <= 3 # Menor ou igual
```

]

---
# Condi√ß√µes: √°lgebra booleana

Podemos combinar compara√ß√µes e predicados usando √°lgebra booleana, um campo da
matem√°tica que lida com valores l√≥gicos.

.pull-left[

```{r}
TRUE & FALSE # x E y
!TRUE # N√ÉO x
!TRUE & FALSE # N√ÉO x E y
```

]

.pull-right[

```{r}
TRUE | FALSE # x OU y
xor(TRUE, TRUE) # x XOU y
TRUE & !FALSE # x E N√ÉO y
```

]

---
class: middle, center

<br><br>

```{r, echo = FALSE, out.width = "90%"}
knitr::include_graphics("img/04_controle_funcoes/algebool.png")
```

<br>

[_R for Data Science (2e)_](https://r4ds.hadley.nz/logicals.html#boolean-algebra)

---
# Condi√ß√µes: conjuntos

Existem opera√ß√µes l√≥gicas para conjuntos. Algumas (como `%in%`) retornam apenas
um valor l√≥gico, mas outras (como `all()` e `any()`) sumarizam vetores l√≥gicos.

```{r}
x <- c(1, 5, 10, 15)
10 %in% x # Pertence ao conjunto
all(x > 7) # Verdadeiro para todos
any(x > 7) # Verdadeiro para algum
```

---
# Voltando para o if

Podemos usar todas as condi√ß√µes que vimos nos √∫ltimos slides dentro do `if`.

```{r}
x <- 10
if (is.numeric(x) & (x < 15)) {
  x * 2
}
```

```{r}
x <- c(1, 2, 3, 4)
if (all(x > 3) | !any(x < 2)) {
  x / 5
}
```

S√≥ n√£o aprendemos ainda como executar algo caso a condi√ß√£o retorne `FALSE`...

---
# else

O maior parceiro do `if` √© o `else`. Ele n√£o tem uma condi√ß√£o, apenas um corpo
que √© executado caso a condi√ß√£o do `if` seja falsa.

> _**Se** `x` for maior que 0, imprimir "positivo". **Sen√£o**, imprimir
"negativo"._

```{r}
x <- -10
if (x > 0) {
  print("positivo")
} else {
  print("negativo")
}
```

Agora s√≥ nos falta uma instru√ß√£o que permita adicionar condi√ß√µes intermedi√°rias.

---
# else if

O `else if` √© uma instru√ß√£o que encadeia condi√ß√µes extras depois de um `if`. Ela
pode aparecer uma ou mais vezes e pode ou n√£o ser fechada com um `else`.

> _**Se** `x` for menor que 3, imprimir "reprovar". **Sen√£o, se** x for menor
> que 5, imprimir "recuperar". **Sen√£o**, imprimir "aprovar"._

```{r}
x <- 8
if (x < 3) {
  print("reprovar")
} else if (x < 5) {
  print("recuperar")
} else {
  print("aprovar")
}
```

---
# Repeti√ß√µes

O que fazer se quisermos executar um certo c√≥digo v√°rias vezes? No exemplo
abaixo, tentamos duplicar `x` at√© que ele fique maior ou igual a 50:

```{r}
x <- 10
if (x < 50) {
  x <- x * 2
  if (x < 50) {
    x <- x * 2
    if (x < 50) {
      x <- x * 2
    }
  }
}
x
```

---
# while

A instru√ß√£o que nos permite executar comando repetidamente se chama `while`. O
nome t√©cnico deste processo √© **itera√ß√£o**, mas √© mais comum falar **loop**.

> _**Enquanto** `x` for menor que 50, multiplic√°-lo por 2._

.pull-left[

```{r}
x <- 10
while (x < 50) {
  x <- x * 2
}
x
```

]

.pull-right[

```{r}
x <- 60
while (x < 50) {
  x <- x * 2 # N√£o executa
}
x
```

]

O que acontece se `x` for negativo quando chegar a hora do `while` ser
executado? O que acontece se esquecermos de atualizar o valor de `x` dentro do
corpo do `while`?

---
# Anatomia do while

O `while` √© muito parecido com tudo que vimos at√© agora: ele tem uma
**condi√ß√£o** entre par√™nteses e um **corpo** entre chaves. O corpo ser√°
executado repetidamente at√© que a condi√ß√£o se torne `FALSE`.

```{r, eval = FALSE}
while (CONDICAO) {
  COMANDO_1
  COMANDO_2
  COMANDO_3
  # Resto do corpo...
}
```

√â important√≠ssimo ter certeza de que existe uma **condi√ß√£o de parada**, ou seja,
uma situa√ß√£o em que o loop termina de executar. Se n√£o fizermos isso, ele vai
rodar permanentemente e teremos que interromper o nosso programa.

Seria bom ter um jeito mais simples de garantir que o `while` vai parar...

---
# for

Um outro tipo de loop √© o `for`. Ele √© um pouco diferente do que vimos at√©
agora, mas segue o mesmo esp√≠rito do `while`.

> _**Para** `i` indo de 1 a 3, imprimi-lo._

```{r}
for (i in 1:3) {
  print(i)
}
```

Diferentemente do `while`, o `for` √© usado quando j√° sabemos quantas vezes
queremos executar o c√≥digo do corpo. Nessas ocasi√µes, √© mais f√°cil definir isso
j√° no come√ßo, assim n√£o precisamos nos preocupar com condi√ß√µes de parada.

---
# Anatomia do for

O `for`, diferente dos outros, tem uma **declara√ß√£o** dentro dos seus
par√™nteses: criamos um objeto, chamado **iterador**, que vai assumir cada um dos
valores de um **vetor**. A partir da√≠, o **corpo** ser√° executado uma vez com
cada valor do iterador.

```{r, eval = FALSE}
for (ITERADOR in VETOR) {
  COMANDO_1
  COMANDO_2
  COMANDO_3
  # Resto do corpo...
}
```

O iterador, apesar de criado dentro da declara√ß√£o do `for`, continua existindo
_fora_ do loop! Ele mant√©m o seu valor da √∫ltima itera√ß√£o.

Obs.: Se quisermos, tamb√©m podemos usar uma lista no lugar do vetor.

---
# Iterando direto nos dados

N√£o necessariamente o iterador precisa ser uma contagem das itera√ß√µes a serem
feitas. Se quisermos, podemos passar nossos dados (uma coluna de uma tabela, por
exemplo) para o iterador e trabalhar direto com eles.

```{r}
for (nota in c(1, 4, 6)) {
  if (nota < 5) {
    print("recuperar")
  } else {
    print("aprovar")
  }
}
```

---
# break() e next()

Existem situa√ß√µes em que queremos sair mais cedo de um loop e em que queremos
pular uma itera√ß√£o espec√≠fica. Fazemos isso, respectivamente, com `break()` e
`next()`, e ambos funcionam tanto com `while` quanto com `for`.

.pull-left[

```{r}
for (x in 1:5) {
  if (x == 4) {
    break()
  }
  print(x)
}
```

]

.pull-right[

```{r}
for (x in 1:5) {
  if (x %% 2 == 0) { # x √© par
    next()
  }
  print(x)
}
```

]

---
# Rodada b√¥nus!

O dplyr tem fun√ß√µes que nos permitem colocar controle de fluxo dentro de um
`mutate()`. A `if_else()` emula um `if` e um `else`, enquanto a `case_when()`
emula um `if` e v√°rios `else if`s. Ambas iteram nas entradas como um `for`.

```{r, include = FALSE}
library(dplyr)
```

```{r}
x <- c(-1, 1, 2, 4, 6)
if_else(x > 0, "positivo", "negativo")
case_when(
  x < 3 ~ "reprovar",
  x < 5 ~ "recuperar",
  TRUE  ~ "aprovar" # Equivale a `else if (TRUE)`, ou seja, `else`
)
```

---
class: middle, center, inverse
# Fun√ß√µes

---
# Motiva√ß√£o

Apesar de j√° termos aprendido sobre fun√ß√µes no _R para Ci√™ncia de Dados I_,
ainda h√° alguns t√≥picos relevantes que precisamos cobrir. Fun√ß√µes s√£o a base da
programa√ß√£o em qualquer linguagem, ent√£o este √© um assunto que vale a pena
relembrar e aprofundar.

Pode n√£o parecer, mas fun√ß√µes tamb√©m s√£o uma forma de controle de fluxo! Uma
fun√ß√£o √© a execu√ß√£o n√£o-linear de um trecho de c√≥digo com algumas regras sobre o
escopo das vari√°veis criadas l√° dentro.

Tamb√©m precisamos preparar o terreno para a pr√≥xima aula, quando vamos aprender
sobre listas e o pacote purrr. Grande parte do tempo vamos estar falando sobre
**programa√ß√£o funcional**, ent√£o a aula de hoje √© essencial.

Mas o que est√° faltando? Entendemos como usar uma fun√ß√£o na pr√°tica, mas quanto
de fato sabemos tudo que √© necess√°rio para construir boas fun√ß√µes?

---
# function

A instru√ß√£o `function` define um trecho de c√≥digo como sendo uma fun√ß√£o. O termo
t√©cnico para isso √© **sub-rotina**.

> _`f` √© uma **fun√ß√£o** que recebe `x` e `y`, e os multiplica._

```{r}
f <- function(x, y) {
  x * y
}
f(2, 3)
f(3, 4)
```

---
# Anatomia do function

O `function` tem uma sintaxe semelhante ao que j√° vimos at√© agora. A maior
diferen√ßa √© que ela tem um **nome**, que ser√° usado para invoc√°-la
posteriormente. Os **argumentos** tamb√©m merecem aten√ß√£o especial, ent√£o logo
vamos falar sobre eles.

```{r, eval = FALSE}
NOME <- function(ARGUMENTOS) {
  COMANDO_1
  COMANDO_2
  # Resto do corpo...
  RETORNO
}
```

O mais importante de entender √© que os comandos s√£o executados em um **escopo**
isolado, ou seja, o que √© criado dentro do corpo n√£o afeta o resto do programa.
Existem exce√ß√µes, mas √© melhor evitarmos um um comportamento diferente.

No geral, o √∫ltimo comando √© o valor de **retorno**, mas isso tamb√©m tem
exce√ß√µes.

---
# return()

No R, o uso do `return()` √© incomum porque uma fun√ß√£o automaticamente retorna o
resultado da sua √∫ltima linha, mas √†s vezes precisamos de um **retorno
antecipado**.

```{r}
quadrado <- function(x) {
  if (!is.numeric(x)) {
    return("Erro")
  }
  x ^ 2
}
quadrado("10")
quadrado(10)
```

---
# Argumentos

Os argumentos de uma fun√ß√£o s√£o objetos que o(a) usu√°rio(a) pode passar para
dentro do escopo na hora de chamar a fun√ß√£o. Eles aparecem como uma sequ√™ncia de
nomes separados por v√≠rgula e podem ou n√£o ter **valores padr√µes**.

```{r}
soma4 <- function(arg1, arg2, arg3, arg4 = 4) {
  arg1 + arg2 + arg3 + arg4
}
tres <- 3
soma4(1, 4 / 2, tres)
```

Um argumento pode receber um valor, um resultado ou um objeto. Um argumento com
valor padr√£o pode ser omitido na hora da chamada e, somente neste caso, ele
receber√° o seu valor padr√£o.

---
# Argumentos: ordem

N√£o √© necess√°rio especificar os nomes dos argumentos se usarmos todos em ordem
(como no slide passado). Se quisermos especificar um argumento sem especificar
um anterior, a√≠ precisamos usar seu nome.

```{r}
soma3 <- function(arg1, arg2 = 2, arg3) {
  arg1 + arg2 + arg3
}
soma3(1, arg3 = 3) # Pulando um argumento
soma3(arg3 = 3, arg2 = 2, arg1 = 1) # Fora de ordem (incomum)
```

---
# Argumentos: dots

A primeira grande novidade sobre fun√ß√µes s√£o os **dots** (formalmente chamados
de "ellipsis"). O usu√°rio pode passar um n√∫mero qualquer de argumentos e todos
ser√£o capturados juntos em uma lista (mais sobre elas na pr√≥xima aula).

```{r}
lista_dots <- function(...) {
  list(...)
}
lista_dots(123, "abc")
```

---
# Argumentos: usando dots

Para usar os dots, podemos transform√°-los em lista como no slide passado ou
podemos redirecion√°-los para outra fun√ß√£o que recebe dots. √â importante notar
que todos os argumentos que v√™m _depois_ dos dots precisam ser nomeados pelo
usu√°rio.

```{r}
somaN <- function(arg1, ..., arg3) {
  sum(arg1, arg3, ...)
}
somaN(1, 2, 3, 4, arg3 = 5)
```

Na pr√°tica, √© muito raro precisarmos dos dots, mas em situa√ß√µes espec√≠ficas eles
s√£o essenciais. Notem como quase todas as fun√ß√µes do dplyr t√™m os dots como
segundo argumento para que possamos criar/filtrar/selecionar quantas colunas
quisermos.

Vamos ver os dots de novo na √∫ltima aula quando falarmos de NSE.

---
# Fun√ß√µes vetorizadas

Fun√ß√µes **vetorizadas** s√£o aquelas que conseguem trabalhar com uma entrada de
qualquer tamanho. No geral queremos garantir que as nossas fun√ß√µes se comportam
assim para que elas funcionem dentro do `mutate()`.

```{css, echo=FALSE}
pre code {
  white-space: pre-wrap;
}
```

.pull-left[

```{r, error = TRUE}
pequeno <- function(xs) {
  if (xs < 5) {
    print("pequeno")
  }
}
pequeno(3:5)
```

Precisamos vetorizar a aplica√ß√£o do `if`.

]

.pull-right[

```{r, error = TRUE}
pequeno <- function(xs) {
  for (x in xs) {
    if (x < 5) {
      print("pequeno")
    }
  }
}
pequeno(3:5)
```

]

---
# Rodada b√¥nus!

**F√°bricas de fun√ß√µes** s√£o fun√ß√µes que retornam fun√ß√µes üòµ‚Äçüí´ Isso √© uma
pr√°tica bastante rara, mas existem fun√ß√µes importantes que se comportam assim
(como a `possibly()` do pacote purrr).

```{r}
cria_arredondador <- function(n_casas) {
  function(valor) {
    round(valor, digits = n_casas)
  }
}

arredonda2 <- cria_arredondador(2)

arredonda2(pi)
```

---
class: middle, center, inverse
# Fim

<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R para Ciência de Dados 2</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <script src="libs/header-attrs-2.21/header-attrs.js"></script>
    <link rel="stylesheet" href="css/xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# R para Ciência de Dados 2
]
.subtitle[
## Controle de fluxo e funções
]
.author[
### <img src = 'https://d33wubrfki0l68.cloudfront.net/9b0699f18268059bdd2e5c21538a29eade7cbd2b/67e5c/img/logo/cursor1-5.png' width = '30%'>
]

---




class: middle, center
# Iniciar gravação!

---
class: middle, center, inverse
# Controle de fluxo

---
# Motivação

Já aprendemos muito sobre o R até agora e sabemos fazer coisas realmente
incríveis com os pacotes que vimos. Mas ainda não falamos (formalmente) sobre um
dos aspectos mais fundamentais da programação: controle de fluxo.

Controle de fluxo é o termo usado para descrever as instruções que nos permitem
controlar a ordem de execução do código. Normalmente elas são divididas em
**condicionais** (`if`, `else`) e **loops** (`while`, `for`), pois assim fica
mais fácil de entender a utilidade de cada instrução.

Apesar da sua importância, esse conceito nem sempre é necessário para fazer uma
análise de dados, por isso esperamos tanto para aprender mais sobre ele. Na
prática, já usamos muito controle de fluxo neste curso, só nunca tão
explicitamente quanto hoje.

Mas por que teríamos interesse em mudar a ordem de execução do código? Até
agora, "de cima para baixo" serviu para tudo que precisávamos... Qual é a
utilidade do controle de fluxo?

---
# Ordem de execução

O que fazer se quisermos executar um certo código somente se uma condição for
atendida? No exemplo abaixo, só podemos fazer a multiplicação de `x` for
numérico.


```r
x &lt;- 10
x * 2
```

```
#&gt; [1] 20
```

Se `x` puder assumir outro tipo de valor, a multiplicação não fará sentido e irá
retornar um erro. Neste caso, o ideal seria "pular" a multiplicação.


```r
x &lt;- "dez"
x * 2
```

```
#&gt; Error in x * 2: non-numeric argument to binary operator
```

---
# if

A instrução que nos permite executar comandos **condicionalmente** se chama
`if`.

&gt; _**Se** `x` for numérico, multiplicá-lo por 2._


```r
x &lt;- 10
if (is.numeric(x)) {
  x * 2
}
```

```
#&gt; [1] 20
```


```r
x &lt;- "dez"
if (is.numeric(x)) {
  x * 2 # Não executa
}
```

---
# Anatomia do if

O `if` é sempre acompanhado de parênteses com uma **condição** (mais sobre isso
no próximo slide) e um par de chaves com um **corpo**, ou seja, todos os
comandos a serem executados caso a condição seja verdadeira.


```r
if (CONDICAO) {
  COMANDO_1
  COMANDO_2
  COMANDO_3
  # Resto do corpo...
}
```

Não há nenhuma restrição sobre o que pode ir dentro do corpo de um `if`;
qualquer código R válido pode ser colocado lá dentro, inclusive outros `if`s.

Antes de prosseguir, precisamos entender exatamente o que conta como condição e
como podemos criar condições mais complexas do que `is.numeric()`.

---
# Condições

As condições do `if` estão intimamente ligadas aos valores lógicos do R: `TRUE`
e `FALSE`. Um `if` precisa que a expressão entre parênteses retorne um único
valor lógico, senão ele não sabe se deve executar o corpo ou não.


```r
x &lt;- 10
is.numeric(x)
```

```
#&gt; [1] TRUE
```

Existem inúmeras outras funções do R que retornam lógicos (chamadas
**predicados**): `is.na()`, `is.character()`, `is.Date()`, `is.factor()`,
`is.list()`, etc.


```r
is.character(x)
```

```
#&gt; [1] FALSE
```

---
# Condições: comparações

Já falamos sobre comparações no _R para Ciência de Dados I_, então basta só
dizer que todas retornam valores lógicos que podem ser usados no `if`.

.pull-left[


```r
1 == 1 # Igual
```

```
#&gt; [1] TRUE
```

```r
2 &gt; 2 # Maior
```

```
#&gt; [1] FALSE
```

```r
3 &lt; 3 # Menor
```

```
#&gt; [1] FALSE
```

]

.pull-right[


```r
1 != 1 # Diferente
```

```
#&gt; [1] FALSE
```

```r
2 &gt;= 2 # Maior ou igual
```

```
#&gt; [1] TRUE
```

```r
3 &lt;= 3 # Menor ou igual
```

```
#&gt; [1] TRUE
```

]

---
# Condições: álgebra booleana

Podemos combinar comparações e predicados usando álgebra booleana, um campo da
matemática que lida com valores lógicos.

.pull-left[


```r
TRUE &amp; FALSE # x E y
```

```
#&gt; [1] FALSE
```

```r
!TRUE # NÃO x
```

```
#&gt; [1] FALSE
```

```r
!TRUE &amp; FALSE # NÃO x E y
```

```
#&gt; [1] FALSE
```

]

.pull-right[


```r
TRUE | FALSE # x OU y
```

```
#&gt; [1] TRUE
```

```r
xor(TRUE, TRUE) # x XOU y
```

```
#&gt; [1] FALSE
```

```r
TRUE &amp; !FALSE # x E NÃO y
```

```
#&gt; [1] TRUE
```

]

---
class: middle, center

&lt;br&gt;&lt;br&gt;

&lt;img src="img/04_controle_funcoes/algebool.png" width="90%" /&gt;

&lt;br&gt;

[_R for Data Science (2e)_](https://r4ds.hadley.nz/logicals.html#boolean-algebra)

---
# Condições: conjuntos

Existem operações lógicas para conjuntos. Algumas (como `%in%`) retornam apenas
um valor lógico, mas outras (como `all()` e `any()`) sumarizam vetores lógicos.


```r
x &lt;- c(1, 5, 10, 15)
10 %in% x # Pertence ao conjunto
```

```
#&gt; [1] TRUE
```

```r
all(x &gt; 7) # Verdadeiro para todos
```

```
#&gt; [1] FALSE
```

```r
any(x &gt; 7) # Verdadeiro para algum
```

```
#&gt; [1] TRUE
```

---
# Voltando para o if

Podemos usar todas as condições que vimos nos últimos slides dentro do `if`.


```r
x &lt;- 10
if (is.numeric(x) &amp; (x &lt; 15)) {
  x * 2
}
```

```
#&gt; [1] 20
```


```r
x &lt;- c(1, 2, 3, 4)
if (all(x &gt; 3) | !any(x &lt; 2)) {
  x / 5
}
```

Só não aprendemos ainda como executar algo caso a condição retorne `FALSE`...

---
# else

O maior parceiro do `if` é o `else`. Ele não tem uma condição, apenas um corpo
que é executado caso a condição do `if` seja falsa.

&gt; _**Se** `x` for maior que 0, imprimir "positivo". **Senão**, imprimir
"negativo"._


```r
x &lt;- -10
if (x &gt; 0) {
  print("positivo")
} else {
  print("negativo")
}
```

```
#&gt; [1] "negativo"
```

Agora só nos falta uma instrução que permita adicionar condições intermediárias.

---
# else if

O `else if` é uma instrução que encadeia condições extras depois de um `if`. Ela
pode aparecer uma ou mais vezes e pode ou não ser fechada com um `else`.

&gt; _**Se** `x` for menor que 3, imprimir "reprovar". **Senão, se** x for menor
&gt; que 5, imprimir "recuperar". **Senão**, imprimir "aprovar"._


```r
x &lt;- 8
if (x &lt; 3) {
  print("reprovar")
} else if (x &lt; 5) {
  print("recuperar")
} else {
  print("aprovar")
}
```

```
#&gt; [1] "aprovar"
```

---
# Repetições

O que fazer se quisermos executar um certo código várias vezes? No exemplo
abaixo, tentamos duplicar `x` até que ele fique maior ou igual a 50:


```r
x &lt;- 10
if (x &lt; 50) {
  x &lt;- x * 2
  if (x &lt; 50) {
    x &lt;- x * 2
    if (x &lt; 50) {
      x &lt;- x * 2
    }
  }
}
x
```

```
#&gt; [1] 80
```

---
# while

A instrução que nos permite executar comando repetidamente se chama `while`. O
nome técnico deste processo é **iteração**, mas é mais comum falar **loop**.

&gt; _**Enquanto** `x` for menor que 50, multiplicá-lo por 2._

.pull-left[


```r
x &lt;- 10
while (x &lt; 50) {
  x &lt;- x * 2
}
x
```

```
#&gt; [1] 80
```

]

.pull-right[


```r
x &lt;- 60
while (x &lt; 50) {
  x &lt;- x * 2 # Não executa
}
x
```

```
#&gt; [1] 60
```

]

O que acontece se `x` for negativo quando chegar a hora do `while` ser
executado? O que acontece se esquecermos de atualizar o valor de `x` dentro do
corpo do `while`?

---
# Anatomia do while

O `while` é muito parecido com tudo que vimos até agora: ele tem uma
**condição** entre parênteses e um **corpo** entre chaves. O corpo será
executado repetidamente até que a condição se torne `FALSE`.


```r
while (CONDICAO) {
  COMANDO_1
  COMANDO_2
  COMANDO_3
  # Resto do corpo...
}
```

É importantíssimo ter certeza de que existe uma **condição de parada**, ou seja,
uma situação em que o loop termina de executar. Se não fizermos isso, ele vai
rodar permanentemente e teremos que interromper o nosso programa.

Seria bom ter um jeito mais simples de garantir que o `while` vai parar...

---
# for

Um outro tipo de loop é o `for`. Ele é um pouco diferente do que vimos até
agora, mas segue o mesmo espírito do `while`.

&gt; _**Para** `i` indo de 1 a 3, imprimi-lo._


```r
for (i in 1:3) {
  print(i)
}
```

```
#&gt; [1] 1
#&gt; [1] 2
#&gt; [1] 3
```

Diferentemente do `while`, o `for` é usado quando já sabemos quantas vezes
queremos executar o código do corpo. Nessas ocasiões, é mais fácil definir isso
já no começo, assim não precisamos nos preocupar com condições de parada.

---
# Anatomia do for

O `for`, diferente dos outros, tem uma **declaração** dentro dos seus
parênteses: criamos um objeto, chamado **iterador**, que vai assumir cada um dos
valores de um **vetor**. A partir daí, o **corpo** será executado uma vez com
cada valor do iterador.


```r
for (ITERADOR in VETOR) {
  COMANDO_1
  COMANDO_2
  COMANDO_3
  # Resto do corpo...
}
```

O iterador, apesar de criado dentro da declaração do `for`, continua existindo
_fora_ do loop! Ele mantém o seu valor da última iteração.

Obs.: Se quisermos, também podemos usar uma lista no lugar do vetor.

---
# Iterando direto nos dados

Não necessariamente o iterador precisa ser uma contagem das iterações a serem
feitas. Se quisermos, podemos passar nossos dados (uma coluna de uma tabela, por
exemplo) para o iterador e trabalhar direto com eles.


```r
for (nota in c(1, 4, 6)) {
  if (nota &lt; 5) {
    print("recuperar")
  } else {
    print("aprovar")
  }
}
```

```
#&gt; [1] "recuperar"
#&gt; [1] "recuperar"
#&gt; [1] "aprovar"
```

---
# break() e next()

Existem situações em que queremos sair mais cedo de um loop e em que queremos
pular uma iteração específica. Fazemos isso, respectivamente, com `break()` e
`next()`, e ambos funcionam tanto com `while` quanto com `for`.

.pull-left[


```r
for (x in 1:5) {
  if (x == 4) {
    break()
  }
  print(x)
}
```

```
#&gt; [1] 1
#&gt; [1] 2
#&gt; [1] 3
```

]

.pull-right[


```r
for (x in 1:5) {
  if (x %% 2 == 0) { # x é par
    next()
  }
  print(x)
}
```

```
#&gt; [1] 1
#&gt; [1] 3
#&gt; [1] 5
```

]

---
# Rodada bônus!

O dplyr tem funções que nos permitem colocar controle de fluxo dentro de um
`mutate()`. A `if_else()` emula um `if` e um `else`, enquanto a `case_when()`
emula um `if` e vários `else if`s. Ambas iteram nas entradas como um `for`.




```r
x &lt;- c(-1, 1, 2, 4, 6)
if_else(x &gt; 0, "positivo", "negativo")
```

```
#&gt; [1] "negativo" "positivo" "positivo" "positivo" "positivo"
```

```r
case_when(
  x &lt; 3 ~ "reprovar",
  x &lt; 5 ~ "recuperar",
  TRUE  ~ "aprovar" # Equivale a `else if (TRUE)`, ou seja, `else`
)
```

```
#&gt; [1] "reprovar"  "reprovar"  "reprovar"  "recuperar" "aprovar"
```

---
class: middle, center, inverse
# Funções

---
# Motivação

Apesar de já termos aprendido sobre funções no _R para Ciência de Dados I_,
ainda há alguns tópicos relevantes que precisamos cobrir. Funções são a base da
programação em qualquer linguagem, então este é um assunto que vale a pena
relembrar e aprofundar.

Pode não parecer, mas funções também são uma forma de controle de fluxo! Uma
função é a execução não-linear de um trecho de código com algumas regras sobre o
escopo das variáveis criadas lá dentro.

Também precisamos preparar o terreno para a próxima aula, quando vamos aprender
sobre listas e o pacote purrr. Grande parte do tempo vamos estar falando sobre
**programação funcional**, então a aula de hoje é essencial.

Mas o que está faltando? Entendemos como usar uma função na prática, mas quanto
de fato sabemos tudo que é necessário para construir boas funções?

---
# function

A instrução `function` define um trecho de código como sendo uma função. O termo
técnico para isso é **sub-rotina**.

&gt; _`f` é uma **função** que recebe `x` e `y`, e os multiplica._


```r
f &lt;- function(x, y) {
  x * y
}
f(2, 3)
```

```
#&gt; [1] 6
```

```r
f(3, 4)
```

```
#&gt; [1] 12
```

---
# Anatomia do function

O `function` tem uma sintaxe semelhante ao que já vimos até agora. A maior
diferença é que ela tem um **nome**, que será usado para invocá-la
posteriormente. Os **argumentos** também merecem atenção especial, então logo
vamos falar sobre eles.


```r
NOME &lt;- function(ARGUMENTOS) {
  COMANDO_1
  COMANDO_2
  # Resto do corpo...
  RETORNO
}
```

O mais importante de entender é que os comandos são executados em um **escopo**
isolado, ou seja, o que é criado dentro do corpo não afeta o resto do programa.
Existem exceções, mas é melhor evitarmos um um comportamento diferente.

No geral, o último comando é o valor de **retorno**, mas isso também tem
exceções.

---
# return()

No R, o uso do `return()` é incomum porque uma função automaticamente retorna o
resultado da sua última linha, mas às vezes precisamos de um **retorno
antecipado**.


```r
quadrado &lt;- function(x) {
  if (!is.numeric(x)) {
    return("Erro")
  }
  x ^ 2
}
quadrado("10")
```

```
#&gt; [1] "Erro"
```

```r
quadrado(10)
```

```
#&gt; [1] 100
```

---
# Argumentos

Os argumentos de uma função são objetos que o usuário pode passar para dentro do
escopo na hora de chamar a função. Eles aparecem como uma sequência de nomes
separados por vírgula e podem ou não ter **valores padrões**.


```r
soma4 &lt;- function(arg1, arg2, arg3, arg4 = 4) {
  arg1 + arg2 + arg3 + arg4
}
tres &lt;- 3
soma4(1, 4 / 2, tres)
```

```
#&gt; [1] 10
```

Um argumento pode receber um valor, um resultado ou um objeto. Um argumento com
valor padrão pode ser omitido na hora da chamada e, somente neste caso, ele
receberá o seu valor padrão.

---
# Argumentos: ordem

Não é necessário especificar os nomes dos argumentos se usarmos todos em ordem
(como no slide passado). Se quisermos especificar um argumento sem especificar
um anterior, aí precisamos usar seu nome.


```r
soma3 &lt;- function(arg1, arg2 = 2, arg3) {
  arg1 + arg2 + arg3
}
soma3(1, arg3 = 3) # Pulando um argumento
```

```
#&gt; [1] 6
```

```r
soma3(arg3 = 3, arg2 = 2, arg1 = 1) # Fora de ordem (incomum)
```

```
#&gt; [1] 6
```

---
# Argumentos: dots

A primeira grande novidade sobre funções são os **dots** (formalmente chamados
de "ellipsis"). O usuário pode passar um número qualquer de argumentos e todos
serão capturados juntos em uma lista (mais sobre elas na próxima aula).


```r
lista_dots &lt;- function(...) {
  list(...)
}
lista_dots(123, "abc")
```

```
#&gt; [[1]]
#&gt; [1] 123
#&gt;
#&gt; [[2]]
#&gt; [1] "abc"
```

---
# Argumentos: usando dots

Para usar os dots, podemos transformá-los em lista como no slide passado ou
podemos redirecioná-los para outra função que recebe dots. É importante notar
que todos os argumentos que vêm _depois_ dos dots precisam ser nomeados pelo
usuário.


```r
somaN &lt;- function(arg1, ..., arg3) {
  sum(arg1, arg3, ...)
}
somaN(1, 2, 3, 4, arg3 = 5)
```

```
#&gt; [1] 15
```

Na prática, é muito raro precisarmos dos dots, mas em situações específicas eles
são essenciais. Notem como quase todas as funções do dplyr têm os dots como
segundo argumento para que possamos criar/filtrar/selecionar quantas colunas
quisermos.

Vamos ver os dots de novo na última aula quando falarmos de NSE.

---
# Funções vetorizadas

Funções **vetorizadas** são aquelas que conseguem trabalhar com uma entrada de
qualquer tamanho. No geral queremos garantir que as nossas funções se comportam
assim para que elas funcionem dentro do `mutate()`.

&lt;style type="text/css"&gt;
pre code {
  white-space: pre-wrap;
}
&lt;/style&gt;

.pull-left[


```r
pequeno &lt;- function(xs) {
  if (xs &lt; 5) {
    print("pequeno")
  }
}
pequeno(3:5)
```

```
#&gt; Error in if (xs &lt; 5) {: the condition has length &gt; 1
```

Precisamos vetorizar a aplicação do `if`.

]

.pull-right[


```r
pequeno &lt;- function(xs) {
  for (x in xs) {
    if (x &lt; 5) {
      print("pequeno")
    }
  }
}
pequeno(3:5)
```

```
#&gt; [1] "pequeno"
#&gt; [1] "pequeno"
```

]

---
# Rodada bônus!

**Fábricas de funções** são funções que retornam funções 😵‍💫 Isso é uma
prática bastante rara, mas existem funções importantes que se comportam assim
(como a `number_format()` do pacote scales).


```r
cria_arredondador &lt;- function(n_casas) {
  function(valor) {
    round(valor, digits = n_casas)
  }
}

arredonda2 &lt;- cria_arredondador(2)

arredonda2(pi)
```

```
#&gt; [1] 3.14
```

---
class: middle, center, inverse
# Fim
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>

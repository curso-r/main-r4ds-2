<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R para Ci√™ncia de Dados 2</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="css/xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# R para Ci√™ncia de Dados 2
]
.subtitle[
## Controle de fluxo e fun√ß√µes
]
.author[
### <img src = 'https://d33wubrfki0l68.cloudfront.net/9b0699f18268059bdd2e5c21538a29eade7cbd2b/67e5c/img/logo/cursor1-5.png' width = '30%'>
]

---




class: middle, center
# Iniciar grava√ß√£o!

---
class: middle, center, inverse
# Controle de fluxo

---
# Motiva√ß√£o

J√° aprendemos muito sobre o R at√© agora e sabemos fazer coisas realmente
incr√≠veis com os pacotes que vimos. Mas ainda n√£o falamos (formalmente) sobre um
dos aspectos mais fundamentais da programa√ß√£o: controle de fluxo.

Controle de fluxo √© o termo usado para descrever as instru√ß√µes que nos permitem
controlar a ordem de execu√ß√£o do c√≥digo. Normalmente elas s√£o divididas em
**condicionais** (`if`, `else`) e **loops** (`while`, `for`), pois assim fica
mais f√°cil de entender a utilidade de cada instru√ß√£o.

Apesar da sua import√¢ncia, esse conceito nem sempre √© necess√°rio para fazer uma
an√°lise de dados, por isso esperamos tanto para aprender mais sobre ele. Na
pr√°tica, j√° usamos muito controle de fluxo neste curso, s√≥ nunca t√£o
explicitamente quanto hoje.

Mas por que ter√≠amos interesse em mudar a ordem de execu√ß√£o do c√≥digo? At√©
agora, "de cima para baixo" serviu para tudo que precis√°vamos... Qual √© a
utilidade do controle de fluxo?

---
# Ordem de execu√ß√£o

O que fazer se quisermos executar um certo c√≥digo somente se uma condi√ß√£o for
atendida? No exemplo abaixo, s√≥ podemos fazer a multiplica√ß√£o de `x` for
num√©rico.


```r
x &lt;- 10
x * 2
```

```
#&gt; [1] 20
```

Se `x` puder assumir outro tipo de valor, a multiplica√ß√£o n√£o far√° sentido e ir√°
retornar um erro. Neste caso, o ideal seria "pular" a multiplica√ß√£o.


```r
x &lt;- "dez"
x * 2
```

```
#&gt; Error in x * 2: non-numeric argument to binary operator
```

---
# if

A instru√ß√£o que nos permite executar comandos **condicionalmente** se chama
`if`.

&gt; _**Se** `x` for num√©rico, multiplic√°-lo por 2._


```r
x &lt;- 10
if (is.numeric(x)) {
  x * 2
}
```

```
#&gt; [1] 20
```


```r
x &lt;- "dez"
if (is.numeric(x)) {
  x * 2 # N√£o executa
}
```

---
# Anatomia do if

O `if` √© sempre acompanhado de par√™nteses com uma **condi√ß√£o** (mais sobre isso
no pr√≥ximo slide) e um par de chaves com um **corpo**, ou seja, todos os
comandos a serem executados caso a condi√ß√£o seja verdadeira.


```r
if (CONDICAO) {
  COMANDO_1
  COMANDO_2
  COMANDO_3
  # Resto do corpo...
}
```

N√£o h√° nenhuma restri√ß√£o sobre o que pode ir dentro do corpo de um `if`;
qualquer c√≥digo R v√°lido pode ser colocado l√° dentro, inclusive outros `if`s.

Antes de prosseguir, precisamos entender exatamente o que conta como condi√ß√£o e
como podemos criar condi√ß√µes mais complexas do que `is.numeric()`.

---
# Condi√ß√µes

As condi√ß√µes do `if` est√£o intimamente ligadas aos valores l√≥gicos do R: `TRUE`
e `FALSE`. Um `if` precisa que a express√£o entre par√™nteses retorne um √∫nico
valor l√≥gico, sen√£o ele n√£o sabe se deve executar o corpo ou n√£o.


```r
x &lt;- 10
is.numeric(x)
```

```
#&gt; [1] TRUE
```

Existem in√∫meras outras fun√ß√µes do R que retornam l√≥gicos (chamadas
**predicados**): `is.na()`, `is.character()`, `is.Date()`, `is.factor()`,
`is.list()`, etc.


```r
is.character(x)
```

```
#&gt; [1] FALSE
```

---
# Condi√ß√µes: compara√ß√µes

J√° falamos sobre compara√ß√µes no _R para Ci√™ncia de Dados I_, ent√£o basta s√≥
dizer que todas retornam valores l√≥gicos que podem ser usados no `if`.

.pull-left[


```r
1 == 1 # Igual
```

```
#&gt; [1] TRUE
```

```r
2 &gt; 2 # Maior
```

```
#&gt; [1] FALSE
```

```r
3 &lt; 3 # Menor
```

```
#&gt; [1] FALSE
```

]

.pull-right[


```r
1 != 1 # Diferente
```

```
#&gt; [1] FALSE
```

```r
2 &gt;= 2 # Maior ou igual
```

```
#&gt; [1] TRUE
```

```r
3 &lt;= 3 # Menor ou igual
```

```
#&gt; [1] TRUE
```

]

---
# Condi√ß√µes: √°lgebra booleana

Podemos combinar compara√ß√µes e predicados usando √°lgebra booleana, um campo da
matem√°tica que lida com valores l√≥gicos.

.pull-left[


```r
TRUE &amp; FALSE # x E y
```

```
#&gt; [1] FALSE
```

```r
!TRUE # N√ÉO x
```

```
#&gt; [1] FALSE
```

```r
!TRUE &amp; FALSE # N√ÉO x E y
```

```
#&gt; [1] FALSE
```

]

.pull-right[


```r
TRUE | FALSE # x OU y
```

```
#&gt; [1] TRUE
```

```r
xor(TRUE, TRUE) # x XOU y
```

```
#&gt; [1] FALSE
```

```r
TRUE &amp; !FALSE # x E N√ÉO y
```

```
#&gt; [1] TRUE
```

]

---
class: middle, center

&lt;br&gt;&lt;br&gt;

&lt;img src="img/04_controle_funcoes/algebool.png" width="90%" /&gt;

&lt;br&gt;

[_R for Data Science (2e)_](https://r4ds.hadley.nz/logicals.html#boolean-algebra)

---
# Condi√ß√µes: conjuntos

Existem opera√ß√µes l√≥gicas para conjuntos. Algumas (como `%in%`) retornam apenas
um valor l√≥gico, mas outras (como `all()` e `any()`) sumarizam vetores l√≥gicos.


```r
x &lt;- c(1, 5, 10, 15)
10 %in% x # Pertence ao conjunto
```

```
#&gt; [1] TRUE
```

```r
all(x &gt; 7) # Verdadeiro para todos
```

```
#&gt; [1] FALSE
```

```r
any(x &gt; 7) # Verdadeiro para algum
```

```
#&gt; [1] TRUE
```

---
# Voltando para o if

Podemos usar todas as condi√ß√µes que vimos nos √∫ltimos slides dentro do `if`.


```r
x &lt;- 10
if (is.numeric(x) &amp; (x &lt; 15)) {
  x * 2
}
```

```
#&gt; [1] 20
```


```r
x &lt;- c(1, 2, 3, 4)
if (all(x &gt; 3) | !any(x &lt; 2)) {
  x / 5
}
```

S√≥ n√£o aprendemos ainda como executar algo caso a condi√ß√£o retorne `FALSE`...

---
# else

O maior parceiro do `if` √© o `else`. Ele n√£o tem uma condi√ß√£o, apenas um corpo
que √© executado caso a condi√ß√£o do `if` seja falsa.

&gt; _**Se** `x` for maior que 0, imprimir "positivo". **Sen√£o**, imprimir
"negativo"._


```r
x &lt;- -10
if (x &gt; 0) {
  print("positivo")
} else {
  print("negativo")
}
```

```
#&gt; [1] "negativo"
```

Agora s√≥ nos falta uma instru√ß√£o que permita adicionar condi√ß√µes intermedi√°rias.

---
# else if

O `else if` √© uma instru√ß√£o que encadeia condi√ß√µes extras depois de um `if`. Ela
pode aparecer uma ou mais vezes e pode ou n√£o ser fechada com um `else`.

&gt; _**Se** `x` for menor que 3, imprimir "reprovar". **Sen√£o, se** x for menor
&gt; que 5, imprimir "recuperar". **Sen√£o**, imprimir "aprovar"._


```r
x &lt;- 8
if (x &lt; 3) {
  print("reprovar")
} else if (x &lt; 5) {
  print("recuperar")
} else {
  print("aprovar")
}
```

```
#&gt; [1] "aprovar"
```

---
# Repeti√ß√µes

O que fazer se quisermos executar um certo c√≥digo v√°rias vezes? No exemplo
abaixo, tentamos duplicar `x` at√© que ele fique maior ou igual a 50:


```r
x &lt;- 10
if (x &lt; 50) {
  x &lt;- x * 2
  if (x &lt; 50) {
    x &lt;- x * 2
    if (x &lt; 50) {
      x &lt;- x * 2
    }
  }
}
x
```

```
#&gt; [1] 80
```

---
# while

A instru√ß√£o que nos permite executar comando repetidamente se chama `while`. O
nome t√©cnico deste processo √© **itera√ß√£o**, mas √© mais comum falar **loop**.

&gt; _**Enquanto** `x` for menor que 50, multiplic√°-lo por 2._

.pull-left[


```r
x &lt;- 10
while (x &lt; 50) {
  x &lt;- x * 2
}
x
```

```
#&gt; [1] 80
```

]

.pull-right[


```r
x &lt;- 60
while (x &lt; 50) {
  x &lt;- x * 2 # N√£o executa
}
x
```

```
#&gt; [1] 60
```

]

O que acontece se `x` for negativo quando chegar a hora do `while` ser
executado? O que acontece se esquecermos de atualizar o valor de `x` dentro do
corpo do `while`?

---
# Anatomia do while

O `while` √© muito parecido com tudo que vimos at√© agora: ele tem uma
**condi√ß√£o** entre par√™nteses e um **corpo** entre chaves. O corpo ser√°
executado repetidamente at√© que a condi√ß√£o se torne `FALSE`.


```r
while (CONDICAO) {
  COMANDO_1
  COMANDO_2
  COMANDO_3
  # Resto do corpo...
}
```

√â important√≠ssimo ter certeza de que existe uma **condi√ß√£o de parada**, ou seja,
uma situa√ß√£o em que o loop termina de executar. Se n√£o fizermos isso, ele vai
rodar permanentemente e teremos que interromper o nosso programa.

Seria bom ter um jeito mais simples de garantir que o `while` vai parar...

---
# for

Um outro tipo de loop √© o `for`. Ele √© um pouco diferente do que vimos at√©
agora, mas segue o mesmo esp√≠rito do `while`.

&gt; _**Para** `i` indo de 1 a 3, imprimi-lo._


```r
for (i in 1:3) {
  print(i)
}
```

```
#&gt; [1] 1
#&gt; [1] 2
#&gt; [1] 3
```

Diferentemente do `while`, o `for` √© usado quando j√° sabemos quantas vezes
queremos executar o c√≥digo do corpo. Nessas ocasi√µes, √© mais f√°cil definir isso
j√° no come√ßo, assim n√£o precisamos nos preocupar com condi√ß√µes de parada.

---
# Anatomia do for

O `for`, diferente dos outros, tem uma **declara√ß√£o** dentro dos seus
par√™nteses: criamos um objeto, chamado **iterador**, que vai assumir cada um dos
valores de um **vetor**. A partir da√≠, o **corpo** ser√° executado uma vez com
cada valor do iterador.


```r
for (ITERADOR in VETOR) {
  COMANDO_1
  COMANDO_2
  COMANDO_3
  # Resto do corpo...
}
```

O iterador, apesar de criado dentro da declara√ß√£o do `for`, continua existindo
_fora_ do loop! Ele mant√©m o seu valor da √∫ltima itera√ß√£o.

Obs.: Se quisermos, tamb√©m podemos usar uma lista no lugar do vetor.

---
# Iterando direto nos dados

N√£o necessariamente o iterador precisa ser uma contagem das itera√ß√µes a serem
feitas. Se quisermos, podemos passar nossos dados (uma coluna de uma tabela, por
exemplo) para o iterador e trabalhar direto com eles.


```r
for (nota in c(1, 4, 6)) {
  if (nota &lt; 5) {
    print("recuperar")
  } else {
    print("aprovar")
  }
}
```

```
#&gt; [1] "recuperar"
#&gt; [1] "recuperar"
#&gt; [1] "aprovar"
```

---
# break() e next()

Existem situa√ß√µes em que queremos sair mais cedo de um loop e em que queremos
pular uma itera√ß√£o espec√≠fica. Fazemos isso, respectivamente, com `break()` e
`next()`, e ambos funcionam tanto com `while` quanto com `for`.

.pull-left[


```r
for (x in 1:5) {
  if (x == 4) {
    break()
  }
  print(x)
}
```

```
#&gt; [1] 1
#&gt; [1] 2
#&gt; [1] 3
```

]

.pull-right[


```r
for (x in 1:5) {
  if (x %% 2 == 0) { # x √© par
    next()
  }
  print(x)
}
```

```
#&gt; [1] 1
#&gt; [1] 3
#&gt; [1] 5
```

]

---
# Rodada b√¥nus!

O dplyr tem fun√ß√µes que nos permitem colocar controle de fluxo dentro de um
`mutate()`. A `if_else()` emula um `if` e um `else`, enquanto a `case_when()`
emula um `if` e v√°rios `else if`s. Ambas iteram nas entradas como um `for`.




```r
x &lt;- c(-1, 1, 2, 4, 6)
if_else(x &gt; 0, "positivo", "negativo")
```

```
#&gt; [1] "negativo" "positivo" "positivo" "positivo" "positivo"
```

```r
case_when(
  x &lt; 3 ~ "reprovar",
  x &lt; 5 ~ "recuperar",
  TRUE  ~ "aprovar" # Equivale a `else if (TRUE)`, ou seja, `else`
)
```

```
#&gt; [1] "reprovar"  "reprovar"  "reprovar"  "recuperar" "aprovar"
```

---
class: middle, center, inverse
# Fun√ß√µes

---
# Motiva√ß√£o

Apesar de j√° termos aprendido sobre fun√ß√µes no _R para Ci√™ncia de Dados I_,
ainda h√° alguns t√≥picos relevantes que precisamos cobrir. Fun√ß√µes s√£o a base da
programa√ß√£o em qualquer linguagem, ent√£o este √© um assunto que vale a pena
relembrar e aprofundar.

Pode n√£o parecer, mas fun√ß√µes tamb√©m s√£o uma forma de controle de fluxo! Uma
fun√ß√£o √© a execu√ß√£o n√£o-linear de um trecho de c√≥digo com algumas regras sobre o
escopo das vari√°veis criadas l√° dentro.

Tamb√©m precisamos preparar o terreno para a pr√≥xima aula, quando vamos aprender
sobre listas e o pacote purrr. Grande parte do tempo vamos estar falando sobre
**programa√ß√£o funcional**, ent√£o a aula de hoje √© essencial.

Mas o que est√° faltando? Entendemos como usar uma fun√ß√£o na pr√°tica, mas quanto
de fato sabemos tudo que √© necess√°rio para construir boas fun√ß√µes?

---
# function

A instru√ß√£o `function` define um trecho de c√≥digo como sendo uma fun√ß√£o. O termo
t√©cnico para isso √© **sub-rotina**.

&gt; _`f` √© uma **fun√ß√£o** que recebe `x` e `y`, e os multiplica._


```r
f &lt;- function(x, y) {
  x * y
}
f(2, 3)
```

```
#&gt; [1] 6
```

```r
f(3, 4)
```

```
#&gt; [1] 12
```

---
# Anatomia do function

O `function` tem uma sintaxe semelhante ao que j√° vimos at√© agora. A maior
diferen√ßa √© que ela tem um **nome**, que ser√° usado para invoc√°-la
posteriormente. Os **argumentos** tamb√©m merecem aten√ß√£o especial, ent√£o logo
vamos falar sobre eles.


```r
NOME &lt;- function(ARGUMENTOS) {
  COMANDO_1
  COMANDO_2
  # Resto do corpo...
  RETORNO
}
```

O mais importante de entender √© que os comandos s√£o executados em um **escopo**
isolado, ou seja, o que √© criado dentro do corpo n√£o afeta o resto do programa.
Existem exce√ß√µes, mas √© melhor evitarmos um um comportamento diferente.

No geral, o √∫ltimo comando √© o valor de **retorno**, mas isso tamb√©m tem
exce√ß√µes.

---
# return()

No R, o uso do `return()` √© incomum porque uma fun√ß√£o automaticamente retorna o
resultado da sua √∫ltima linha, mas √†s vezes precisamos de um **retorno
antecipado**.


```r
quadrado &lt;- function(x) {
  if (!is.numeric(x)) {
    return("Erro")
  }
  x ^ 2
}
quadrado("10")
```

```
#&gt; [1] "Erro"
```

```r
quadrado(10)
```

```
#&gt; [1] 100
```

---
# Argumentos

Os argumentos de uma fun√ß√£o s√£o objetos que o(a) usu√°rio(a) pode passar para
dentro do escopo na hora de chamar a fun√ß√£o. Eles aparecem como uma sequ√™ncia de
nomes separados por v√≠rgula e podem ou n√£o ter **valores padr√µes**.


```r
soma4 &lt;- function(arg1, arg2, arg3, arg4 = 4) {
  arg1 + arg2 + arg3 + arg4
}
tres &lt;- 3
soma4(1, 4 / 2, tres)
```

```
#&gt; [1] 10
```

Um argumento pode receber um valor, um resultado ou um objeto. Um argumento com
valor padr√£o pode ser omitido na hora da chamada e, somente neste caso, ele
receber√° o seu valor padr√£o.

---
# Argumentos: ordem

N√£o √© necess√°rio especificar os nomes dos argumentos se usarmos todos em ordem
(como no slide passado). Se quisermos especificar um argumento sem especificar
um anterior, a√≠ precisamos usar seu nome.


```r
soma3 &lt;- function(arg1, arg2 = 2, arg3) {
  arg1 + arg2 + arg3
}
soma3(1, arg3 = 3) # Pulando um argumento
```

```
#&gt; [1] 6
```

```r
soma3(arg3 = 3, arg2 = 2, arg1 = 1) # Fora de ordem (incomum)
```

```
#&gt; [1] 6
```

---
# Argumentos: dots

A primeira grande novidade sobre fun√ß√µes s√£o os **dots** (formalmente chamados
de "ellipsis"). O usu√°rio pode passar um n√∫mero qualquer de argumentos e todos
ser√£o capturados juntos em uma lista (mais sobre elas na pr√≥xima aula).


```r
lista_dots &lt;- function(...) {
  list(...)
}
lista_dots(123, "abc")
```

```
#&gt; [[1]]
#&gt; [1] 123
#&gt; 
#&gt; [[2]]
#&gt; [1] "abc"
```

---
# Argumentos: usando dots

Para usar os dots, podemos transform√°-los em lista como no slide passado ou
podemos redirecion√°-los para outra fun√ß√£o que recebe dots. √â importante notar
que todos os argumentos que v√™m _depois_ dos dots precisam ser nomeados pelo
usu√°rio.


```r
somaN &lt;- function(arg1, ..., arg3) {
  sum(arg1, arg3, ...)
}
somaN(1, 2, 3, 4, arg3 = 5)
```

```
#&gt; [1] 15
```

Na pr√°tica, √© muito raro precisarmos dos dots, mas em situa√ß√µes espec√≠ficas eles
s√£o essenciais. Notem como quase todas as fun√ß√µes do dplyr t√™m os dots como
segundo argumento para que possamos criar/filtrar/selecionar quantas colunas
quisermos.

Vamos ver os dots de novo na √∫ltima aula quando falarmos de NSE.

---
# Fun√ß√µes vetorizadas

Fun√ß√µes **vetorizadas** s√£o aquelas que conseguem trabalhar com uma entrada de
qualquer tamanho. No geral queremos garantir que as nossas fun√ß√µes se comportam
assim para que elas funcionem dentro do `mutate()`.

&lt;style type="text/css"&gt;
pre code {
  white-space: pre-wrap;
}
&lt;/style&gt;

.pull-left[


```r
pequeno &lt;- function(xs) {
  if (xs &lt; 5) {
    print("pequeno")
  }
}
pequeno(3:5)
```

```
#&gt; Error in if (xs &lt; 5) {: the condition has length &gt; 1
```

Precisamos vetorizar a aplica√ß√£o do `if`.

]

.pull-right[


```r
pequeno &lt;- function(xs) {
  for (x in xs) {
    if (x &lt; 5) {
      print("pequeno")
    }
  }
}
pequeno(3:5)
```

```
#&gt; [1] "pequeno"
#&gt; [1] "pequeno"
```

]

---
# Rodada b√¥nus!

**F√°bricas de fun√ß√µes** s√£o fun√ß√µes que retornam fun√ß√µes üòµ‚Äçüí´ Isso √© uma
pr√°tica bastante rara, mas existem fun√ß√µes importantes que se comportam assim
(como a `possibly()` do pacote purrr).


```r
cria_arredondador &lt;- function(n_casas) {
  function(valor) {
    round(valor, digits = n_casas)
  }
}

arredonda2 &lt;- cria_arredondador(2)

arredonda2(pi)
```

```
#&gt; [1] 3.14
```

---
class: middle, center, inverse
# Fim
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>

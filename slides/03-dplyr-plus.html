<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R para Ci√™ncia de Dados 2</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/custom-intro.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# R para Ci√™ncia de Dados 2
## dplyr ++
### <img src = 'https://d33wubrfki0l68.cloudfront.net/9b0699f18268059bdd2e5c21538a29eade7cbd2b/67e5c/img/logo/cursor1-5.png' width = '30%'>
### Agosto de 2020

---




class: titulo
# O pacote dplyr

---
## Verbos principais

J√° vimos que com os principais verbos do `{dplyr}` j√° conseguimos fazer diversas opera√ß√µes de manipula√ß√£o de bases de dados.

.pull-left[
- Selecionar colunas: `select()`

- Ordenar linhas: `arrange()`

- Filtrar linhas: `filter()`

- Criar ou modificar colunas: `mutate()`

- Agrupar e sumarizar: `group_by()` + `summarise()`
]

.pull-right[
&lt;img src="img/03-dplyr-plus/arte_dplyr.png" width="100%" /&gt;
]

&lt;center&gt;
<span style="color:#6495ed; font-weight: bold;">Mas o dplyr tem muito mais para oferecer. MUITO MAIS!</span>
&lt;/center&gt;

---
## Miscel√¢nea de fun√ß√µes √∫teis

Para aquecer, vamos listar uma miscel√¢nea de fun√ß√µes muito √∫teis, mas menos conhecidas do `{dplyr}`.

- `bind_rows()`: para empilhar duas bases.

- `case_when()`: generaliza√ß√£o da `ifelse()` para v√°rias condi√ß√µes.

- `first()`, `last()`: para pegar o primeiro ou √∫ltimo valor de um vetor/coluna.

- `na_if()`: para transformar um determinado valor de um vetor/coluna em `NA`.

- `coalesce()`: para substituir os `NAs` de uma coluna pelos valores equivalentes de uma segunda coluna.

- `lag()`, `lead()`: para gerar colunas defasadas.

- `pull()`: para transformar uma coluna da base em um vetor.

- `slice_sample`: para gerar amostras da base.

---
## bind_rows()

Vamos usar a fun√ß√£o `bind_rows()` para juntarmos duas bases com as mesmas colunas.


```r
# Juntando duas bases
imdb_2015 &lt;- readr::read_rds("../data/imdb_por_ano/imdb_2015.rds")
imdb_2016 &lt;- readr::read_rds("../data/imdb_por_ano/imdb_2016.rds")

bind_rows(imdb_2015, imdb_2016) %&gt;% head()
```

```
## # A tibble: 6 x 15
##   titulo   ano diretor duracao cor   generos pais  classificacao orcamento
##   &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;     &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;             &lt;int&gt;
## 1 Aveng‚Ä¶  2015 Joss W‚Ä¶     141 Color Action‚Ä¶ USA   A partir de ‚Ä¶ 250000000
## 2 Juras‚Ä¶  2015 Colin ‚Ä¶     124 Color Action‚Ä¶ USA   A partir de ‚Ä¶ 150000000
## 3 Furio‚Ä¶  2015 James ‚Ä¶     140 Color Action‚Ä¶ USA   A partir de ‚Ä¶ 190000000
## 4 The G‚Ä¶  2015 Peter ‚Ä¶      93 Color Advent‚Ä¶ USA   Livre                NA
## 5 Jupit‚Ä¶  2015 Lana W‚Ä¶     127 Color Action‚Ä¶ USA   A partir de ‚Ä¶ 176000000
## 6 Insid‚Ä¶  2015 Pete D‚Ä¶      95 Color Advent‚Ä¶ USA   Livre         175000000
## # ‚Ä¶ with 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;,
## #   likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt;
```

---
##  

Neste caso, a fun√ß√£o `bind_rows()` √© equivalente √† fun√ß√£o `rbind()`.


```r
# Juntando duas bases
imdb_2015 &lt;- readr::read_rds("../data/imdb_por_ano/imdb_2015.rds")
imdb_2016 &lt;- readr::read_rds("../data/imdb_por_ano/imdb_2016.rds")

rbind(imdb_2015, imdb_2016) %&gt;% head()
```

```
## # A tibble: 6 x 15
##   titulo   ano diretor duracao cor   generos pais  classificacao orcamento
##   &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;     &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;             &lt;int&gt;
## 1 Aveng‚Ä¶  2015 Joss W‚Ä¶     141 Color Action‚Ä¶ USA   A partir de ‚Ä¶ 250000000
## 2 Juras‚Ä¶  2015 Colin ‚Ä¶     124 Color Action‚Ä¶ USA   A partir de ‚Ä¶ 150000000
## 3 Furio‚Ä¶  2015 James ‚Ä¶     140 Color Action‚Ä¶ USA   A partir de ‚Ä¶ 190000000
## 4 The G‚Ä¶  2015 Peter ‚Ä¶      93 Color Advent‚Ä¶ USA   Livre                NA
## 5 Jupit‚Ä¶  2015 Lana W‚Ä¶     127 Color Action‚Ä¶ USA   A partir de ‚Ä¶ 176000000
## 6 Insid‚Ä¶  2015 Pete D‚Ä¶      95 Color Advent‚Ä¶ USA   Livre         175000000
## # ‚Ä¶ with 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;,
## #   likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt;
```

&lt;br&gt;

**Observa√ß√£o**: tanto para a `bind_rows()` quanto para a `rbind()`, a ordem das colunas em ambas as bases pode ser diferente. As colunas s√£o empilhadas pelo nome.

---
## 

Podemos tamb√©m usar a fun√ß√£o `bind_rows()` para juntar v√°rias tabelas. Aqui, todas as tabelas continuam tendo as mesmas colunas.


```r
arquivos &lt;- list.files("../data/imdb_por_ano/", full.names = TRUE)

arquivos %&gt;%
  purrr::map(readr::read_rds) %&gt;%
  bind_rows() %&gt;% 
  head()
```

```
## # A tibble: 6 x 15
##   titulo   ano diretor duracao cor   generos pais  classificacao orcamento
##   &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;     &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;             &lt;int&gt;
## 1 Intol‚Ä¶  1916 D.W. G‚Ä¶     123 Blac‚Ä¶ Drama|‚Ä¶ USA   Outros           385907
## 2 Over ‚Ä¶  1920 Harry ‚Ä¶     110 Blac‚Ä¶ Crime|‚Ä¶ USA   Outros           100000
## 3 The B‚Ä¶  1925 King V‚Ä¶     151 Blac‚Ä¶ Drama|‚Ä¶ USA   Outros           245000
## 4 The B‚Ä¶  1929 Harry ‚Ä¶     100 Blac‚Ä¶ Musica‚Ä¶ USA   Outros           379000
## 5 Hell'‚Ä¶  1930 Howard‚Ä¶      96 Blac‚Ä¶ Drama|‚Ä¶ USA   Outros          3950000
## 6 A Far‚Ä¶  1932 Frank ‚Ä¶      79 Blac‚Ä¶ Drama|‚Ä¶ USA   Outros           800000
## # ‚Ä¶ with 6 more variables: receita &lt;int&gt;, nota_imdb &lt;dbl&gt;,
## #   likes_facebook &lt;int&gt;, ator_1 &lt;chr&gt;, ator_2 &lt;chr&gt;, ator_3 &lt;chr&gt;
```

**Observa√ß√£o**: a fun√ß√£o `purrr::map()` est√° aplicando a fun√ß√£o `readr::read_rds()` a todos os elementos do vetor `arquivos` e devolvendo uma lista de tibbles, uma para cada ano da base IMDB. Aprenderemos mais sobre essa fun√ß√£o na aula de `purrr`.

---
## 

Como a fun√ß√£o `map()` devolve uma lista, a fun√ß√£o `rbind()` n√£o funcionaria.


```r
arquivos &lt;- list.files("../data/imdb_por_ano/", full.names = TRUE)

arquivos %&gt;%
  purrr::map(readr::read_rds) %&gt;%
  rbind()
```

```
##   [,1]    [,2]    [,3]    [,4]    [,5]    [,6]    [,7]    [,8]    [,9]   
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
##   [,10]   [,11]   [,12]   [,13]   [,14]   [,15]   [,16]   [,17]   [,18]  
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
##   [,19]   [,20]   [,21]   [,22]   [,23]   [,24]   [,25]   [,26]   [,27]  
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
##   [,28]   [,29]   [,30]   [,31]   [,32]   [,33]   [,34]   [,35]   [,36]  
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
##   [,37]   [,38]   [,39]   [,40]   [,41]   [,42]   [,43]   [,44]   [,45]  
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
##   [,46]   [,47]   [,48]   [,49]   [,50]   [,51]   [,52]   [,53]   [,54]  
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
##   [,55]   [,56]   [,57]   [,58]   [,59]   [,60]   [,61]   [,62]   [,63]  
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
##   [,64]   [,65]   [,66]   [,67]   [,68]   [,69]   [,70]   [,71]   [,72]  
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
##   [,73]   [,74]   [,75]   [,76]   [,77]   [,78]   [,79]   [,80]   [,81]  
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
##   [,82]   [,83]   [,84]   [,85]   [,86]   [,87]   [,88]   [,89]   [,90]  
## . List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15 List,15
```

---
## 

Al√©m disso, a fun√ß√£o `bind_rows()` pode ser utilizada para empilhar bases com colunas diferentes.


```r
tab1 &lt;- tibble::tibble(
  var1 = c(1, 2, 3),
  var2 = c("a", "b", "c"),
  var3 = c(10, 20, 30)
)

tab2 &lt;- tibble::tibble(
  var2 = c("d", "e", "f"),
  var1 = c(4, 5, 6)
)

bind_rows(tab1, tab2)
```

```
## # A tibble: 6 x 3
##    var1 var2   var3
##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     1 a        10
## 2     2 b        20
## 3     3 c        30
## 4     4 d        NA
## 5     5 e        NA
## 6     6 f        NA
```

---
## 

Ao contr√°rio da fun√ß√£o `rbind()`.


```r
tab1 &lt;- tibble::tibble(
  var1 = c(1, 2, 3),
  var2 = c("a", "b", "c"),
  var3 = c(10, 20, 30)
)

tab2 &lt;- tibble::tibble(
  var2 = c("d", "e", "f"),
  var1 = c(4, 5, 6)
)

rbind(tab1, tab2)
```

```
## Error in rbind(deparse.level, ...): numbers of columns of arguments do not match
```


**Extra**: o `{dplyr}` tamb√©m possui a fun√ß√£o `bind_cols()`, para juntar duas bases colocando suas colunas lado-a-lado.

---
## case_when()

A fun√ß√£o `case_when()` generaliza a fun√ß√£o `ifelse()`, permitindo colocar quantas condi√ß√µes quisermos.


```r
x &lt;- sample(-10:10, 10)

case_when(
  x &lt; 0 ~ "negativo",
  x == 0 ~ "zero",
  x &gt; 0 ~ "positivo"
)
```

```
##  [1] "positivo" "positivo" "positivo" "zero"     "positivo" "negativo"
##  [7] "positivo" "negativo" "negativo" "negativo"
```

Com `ifelse()`, precisar√≠amos usar a fun√ß√£o duas vezes:


```r
ifelse(x &lt; 0, "negativo", ifelse(x == 0, "zero", "positivo"))
```

```
##  [1] "positivo" "positivo" "positivo" "zero"     "positivo" "negativo"
##  [7] "positivo" "negativo" "negativo" "negativo"
```

---
## 

A ordem das condi√ß√µes √© importante no `case_when()`, pois os testes s√£o realizados na ordem em que eles aparecem.


```r
mtcars %&gt;%
  mutate(
    mpg_cat = case_when(
      mpg &lt; 15 ~ "economico",
      mpg &lt; 22 ~ "regular",
      mpg &gt;= 22 ~ "bebe bem"
    )
  ) %&gt;% 
  head(8)
```

```
##    mpg cyl  disp  hp drat    wt  qsec vs am gear carb   mpg_cat
## 1 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4   regular
## 2 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4   regular
## 3 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1  bebe bem
## 4 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1   regular
## 5 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2   regular
## 6 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1   regular
## 7 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 economico
## 8 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2  bebe bem
```

Repare que os carros com `mpg &lt; 15` entram na primeira condi√ß√£o, a segunda condi√ß√£o pega os carros com `15 &lt;= mpg &lt; 25`. 

---
## 

Como a √∫ltima condi√ß√£o √© complementar, isto √©, as observa√ß√µes que n√£o entrarm nas condi√ß√µes anteriores com certeza entrar√£o na √∫ltima condi√ß√£o, podemos substitu√≠-la por um simples `TRUE`.


```r
mtcars %&gt;%
  mutate(
    mpg_cat = case_when(
      mpg &lt; 15 ~ "economico",
      mpg &lt; 22 ~ "regular",
      TRUE ~ "bebe bem"
    )
  ) %&gt;% 
  head(8)
```

```
##    mpg cyl  disp  hp drat    wt  qsec vs am gear carb   mpg_cat
## 1 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4   regular
## 2 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4   regular
## 3 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1  bebe bem
## 4 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1   regular
## 5 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2   regular
## 6 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1   regular
## 7 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 economico
## 8 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2  bebe bem
```


---
## 

O `case_when()` √© muito √∫til dentro do `mutate()`.


```r
mtcars %&gt;%
  mutate(
    mpg_cat = case_when(
      mpg &lt; 15 ~ "economico",
      mpg &lt; 22 ~ "regular",
      TRUE ~ "bebe bem"
    )
  ) %&gt;% 
  head(14)
```

```
##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb   mpg_cat
## 1  21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4   regular
## 2  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4   regular
## 3  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1  bebe bem
## 4  21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1   regular
## 5  18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2   regular
## 6  18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1   regular
## 7  14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4 economico
## 8  24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2  bebe bem
## 9  22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2  bebe bem
## 10 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4   regular
## 11 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4   regular
## 12 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3   regular
## 13 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3   regular
## 14 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3   regular
```


---
## first(), last()

Essas fun√ß√µes retornam o primeiro e √∫ltimo valor de um vetor.


```r
x &lt;- c(1, 12, 30, 41, 15)

first(x)
```

```
## [1] 1
```

```r
last(x)
```

```
## [1] 15
```

---
## 

S√£o fun√ß√µes √∫teis quando temos algum tipo de ordem:


```r
tab &lt;- tibble::tibble(
  tempo = c(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4),
  var = c(1, 4, 10, 33, 1, 3, 0, 21, 12, 7, 9, 17),
  grupo = c(rep("a", 4), rep("b", 4), rep("c", 4))
)

tab %&gt;%
  group_by(grupo) %&gt;%
  arrange(tempo, .by_group = TRUE) %&gt;%
  mutate(inicio = first(var), fim = last(var))
```

```
## # A tibble: 12 x 5
## # Groups:   grupo [3]
##    tempo   var grupo inicio   fim
##    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1     1     1 a          1    33
##  2     2     4 a          1    33
##  3     3    10 a          1    33
##  4     4    33 a          1    33
##  5     1     1 b          1    21
##  6     2     3 b          1    21
##  7     3     0 b          1    21
##  8     4    21 b          1    21
##  9     1    12 c         12    17
## 10     2     7 c         12    17
## 11     3     9 c         12    17
## 12     4    17 c         12    17
```


---
## na_if()

Transforma um valor especificado em `NA`.


```r
tab &lt;- tibble::tibble(
  var = c(1, 10, 2, -99, 10, -99)
)

tab %&gt;% mutate(var = na_if(var, -99))
```

```
## # A tibble: 6 x 1
##     var
##   &lt;dbl&gt;
## 1     1
## 2    10
## 3     2
## 4    NA
## 5    10
## 6    NA
```


---
## coalesce()

A fun√ß√£o `coalesce()` substitui os `NA`s de uma coluna pelos valores equivalentes de uma segunda coluna. No exemplo abaixo, substituimos os `NAs` da coluna `var1` pelos valores equivalentes da coluna `var2` (criamos uma nova coluna `var3` com o resultado para visualizarmos melhor). No caso em que as duas colunas apresentavam `NA`, a coluna `var3` continuou com o `NA`.


```r
tab &lt;- tibble::tibble(
  var1 = c(1, 2, NA, 10, NA, NA),
  var2 = c(NA, 2, 2, 3, 0, NA)
)

tab %&gt;% mutate(var3 = coalesce(var1, var2))
```

```
## # A tibble: 6 x 3
##    var1  var2  var3
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1    NA     1
## 2     2     2     2
## 3    NA     2     2
## 4    10     3    10
## 5    NA     0     0
## 6    NA    NA    NA
```

---
## 

Voc√™ tamb√©m pode usar para substituir `NA`s de uma vari√°vel por um √∫nico valor.


```r
tab %&gt;% mutate(var3 = coalesce(var1, 33))
```

```
## # A tibble: 6 x 3
##    var1  var2  var3
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1    NA     1
## 2     2     2     2
## 3    NA     2    33
## 4    10     3    10
## 5    NA     0    33
## 6    NA    NA    33
```

Ou simplesmente usar a fun√ß√£o `tidyr::replace_na()`.


```r
tab %&gt;% tidyr::replace_na(replace = list(var1 = 33, var2 = 66))
```

```
## # A tibble: 6 x 2
##    var1  var2
##   &lt;dbl&gt; &lt;dbl&gt;
## 1     1    66
## 2     2     2
## 3    33     2
## 4    10     3
## 5    33     0
## 6    33    66
```

---
## lag(), lead()

Essas fun√ß√µes devolvem o valor defasado e valor futuro.


```r
tab &lt;- tibble::tibble(
  tempo = c(1, 2, 3, 4, 5),
  var = c(1, 4, 10, 33, 20)
)

tab %&gt;% 
  dplyr::mutate(
    var_lag = lag(var),
    var_lead = lead(var)
  )
```

```
## # A tibble: 5 x 4
##   tempo   var var_lag var_lead
##   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;
## 1     1     1      NA        4
## 2     2     4       1       10
## 3     3    10       4       33
## 4     4    33      10       20
## 5     5    20      33       NA
```


---
## pull()

Devolve uma coluna da base como vetor.


```r
mtcars %&gt;% pull(mpg)
```

```
##  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
## [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
## [31] 15.0 21.4
```


---
## slice_sample()

Essa fun√ß√£o pode ser utilizada para pegarmos uma amostra de linhas da nossa base.

No exemplo abaixo, pegamos uma amostra de tamanho 10 da base mtcars.


```r
slice_sample(mtcars, n = 10)
```

```
##                   mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Toyota Corolla   33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
## AMC Javelin      15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
## Merc 280         19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
## Porsche 914-2    26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
## Datsun 710       22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Toyota Corona    21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
## Merc 280C        17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
## Fiat 128         32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
## Lotus Europa     30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
## Dodge Challenger 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
```

---
## 

Agora, pegamos 50% da base mtcars.


```r
slice_sample(mtcars, prop = 0.5)
```

```
##                    mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
## Datsun 710        22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
## Dodge Challenger  15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
## Toyota Corolla    33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
## Ford Pantera L    15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
## Merc 280C         17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
## Fiat X1-9         27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
## Merc 450SL        17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
## Porsche 914-2     26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
## Mazda RX4 Wag     21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
## Merc 280          19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
## Merc 230          22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
## Merc 240D         24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
## Volvo 142E        21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
## Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
## Camaro Z28        13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
```

---
class: titulo
# dplyr 1.0

---
# Novo dplyr

A vers√£o 1.0 do pacote `dplyr` foi oficialmente lan√ßada em junho de 2020 e contou com diversas novidades Vamos falar das principais mudan√ßas:

- A nova fun√ß√£o `across()`, que facilita aplicar uma mesma opera√ß√£o em v√°rias colunas.

- A repaginada fun√ß√£o `rowwise()`, para fazer opera√ß√µes por linha.

- Novas funcionalidades das fun√ß√µes `select()` e `rename()` e a nova fun√ß√£o `relocate()`.

---
## Motiva√ß√£o

Base de dados de venda de casas na cidade de Ames, nos Estados Unidos.

- 2930 linhas e 77 colunas.

- Cada linha corresponde a uma casa vendida e cada coluna a uma caracter√≠stica da casa ou da venda.

- Vers√£o traduzida: fa√ßa o download [clicando aqui](https://github.com/curso-r/main-r4ds2/raw/master/data/ames.rds).

- Base original:


```r
install.packages("AmesHousing")

data(ames_raw, package = "AmesHousing")
```



---
## across()

A fun√ß√£o `across()` substitui a fam√≠lia de verbos `verbo_all()`, `verbo_if` e `verbo_at()`. A ideia √© facilitar a aplica√ß√£o de uma opera√ß√£o a diversas colunas da base. Para sumarizar a base para mais de uma vari√°vel, antigamente faz√≠amos


```r
ames %&gt;%
  group_by(geral_qualidade) %&gt;%
  summarise(
    lote_area_media = mean(lote_area, na.rm = TRUE),
    venda_valor_medio = mean(venda_valor, na.rm = TRUE)
  )
```

```
## # A tibble: 10 x 3
##    geral_qualidade lote_area_media venda_valor_medio
##              &lt;int&gt;           &lt;dbl&gt;             &lt;dbl&gt;
##  1               1          15214.            48725 
##  2               2           9326.            52325.
##  3               3           9439.            83186.
##  4               4           8464.           106485.
##  5               5           9995.           134753.
##  6               6           9788.           162130.
##  7               7          10309.           205026.
##  8               8          10618.           270914.
##  9               9          12777.           368337.
## 10              10          18071.           450217.
```

---
## 

Ou ent√£o


```r
ames %&gt;%
  group_by(geral_qualidade) %&gt;%
  summarise_at(
    .vars = vars(lote_area, venda_valor),
    ~mean(.x, na.rm = TRUE)
  )
```

```
## # A tibble: 10 x 3
##    geral_qualidade lote_area venda_valor
##              &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;
##  1               1    15214.      48725 
##  2               2     9326.      52325.
##  3               3     9439.      83186.
##  4               4     8464.     106485.
##  5               5     9995.     134753.
##  6               6     9788.     162130.
##  7               7    10309.     205026.
##  8               8    10618.     270914.
##  9               9    12777.     368337.
## 10              10    18071.     450217.
```

---
## 

Com a nova fun√ß√£o `across()`, fazemos


```r
ames %&gt;%
  group_by(geral_qualidade) %&gt;%
  summarise(across(
    .cols = c(lote_area, venda_valor),
    .fns = mean, na.rm = TRUE
  ))
```

```
## # A tibble: 10 x 3
##    geral_qualidade lote_area venda_valor
##              &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;
##  1               1    15214.      48725 
##  2               2     9326.      52325.
##  3               3     9439.      83186.
##  4               4     8464.     106485.
##  5               5     9995.     134753.
##  6               6     9788.     162130.
##  7               7    10309.     205026.
##  8               8    10618.     270914.
##  9               9    12777.     368337.
## 10              10    18071.     450217.
```

A sintaxe √© parecida com a fun√ß√£o `summarise_at()`, mas agora n√£o precisamos mais usar a fun√ß√£o `vars()` e nem usar `list(nome_da_funcao)` ou `~nome_da_funcao(.x)` para definir a fun√ß√£o aplicada nas colunas.

---
## rowwise()

---
## select(), rename()

---
## relocate()

---
## Across

across() makes it possible to compute useful summaries that were previously impossible. For example, it‚Äôs now easy to summarise numeric vectors with one function, factors with another, and still compute the number of rows in each group:

  

```r
df %&gt;%
  group_by(g1, g2) %&gt;% 
  summarise(
    across(where(is.numeric), mean), 
    across(where(is.factor), nlevels),
    n = n(), 
  )
```
  
across() reduces the number of functions that dplyr needs to provide. This makes dplyr easier for you to use (because there are fewer functions to remember) and easier for us to develop (since we only need to implement one function for each new verb, not four).

With the where() helper, across() unifies _if and _at semantics, allowing combinations that used to be impossible. For example, you can now transform all numeric columns whose name begins with ‚Äúx‚Äù: across(where(is.numeric) &amp; starts_with("x")).

across() doesn‚Äôt need vars(). The _at() functions are the only place in dplyr where you have to use vars(), which makes them unusual, and hence harder to learn and remember.


---
class: inverse, middle, center

# Pivotagem

---

# pivot_wider()


```r
knitr::include_graphics("img/03-dplyr-plus/wider.png")
```

&lt;img src="img/03-dplyr-plus/wider.png" width="2560" /&gt;

(retirado do livro [r4ds](https://r4ds.had.co.nz))

---

# pivot_longer()


```r
knitr::include_graphics("img/03-dplyr-plus/longer.png")
```

&lt;img src="img/03-dplyr-plus/longer.png" width="2560" /&gt;

(retirado do livro [r4ds](https://r4ds.had.co.nz))

---
class: center

# Vamos ao R!

&lt;img src="img/03-dplyr-plus/gato.gif" width="80%" style="display: block; margin: auto;" /&gt;

&lt;!-- Finalizando ----------------------------------------------------------- --&gt;

---
class: inverse, middle, center

# Resumo

---

# Resumo

Hoje vimos alguns conceitos de

- Importa√ß√£o de dados com `{readxl}` e `{readr}`, e uma palhinha do `{purrr}`
- Os cinco verbos do `{dplyr}`
- Conex√£o com banco de dados e a fun√ß√£o `collect()`
- Pivotagem com as fun√ß√µes `pivot_wider()` e `pivot_longer()`

---

# Algumas refer√™ncias

- [Material de tidyverse da UFPR](http://www.leg.ufpr.br/~walmes/ensino/dsbd-linprog/slides/02-r-tidyverse.html#1)
- [Material da Curso-R](https://www.curso-r.com/material/)
- [Apresenta√ß√£o Garret Grolemund](https://github.com/rstudio/webinars/blob/master/05-Data-Wrangling-with-R-and-RStudio/wrangling-webinar.pdf)

---

### Joins com `{dplyr}`

--

Exemplos sem exerc√≠cio:

### `nest()`/`unnest()` com `{tidyr}`

### Fazendo fun√ß√µes que usam `dplyr` com `{{ }}`

---

# Bases de dados

Base do SINESP: Sistema Nacional de Informa√ß√µes de Seguran√ßa P√∫blica

- `munic√≠pio`
- `sigla_uf`
- `regiao`
- `mes_ano`
- `vitima`

--

Para o exerc√≠cio de joins, vamos considerar a base Estadual tamb√©m:

- `uf`
- `tipo_crime`
- `ano`
- `mes`
- `ocorrencias`

### As bases j√° est√£o no reposit√≥rio

---

# Taxonomia

## ‚Ü™Ô∏è `{pacote}`

--

## ‚Ü™Ô∏è `pacote::funcao()` ou `funcao()`

--

## ‚Ü™Ô∏è `da_` para bases de dados

&lt;!-- Parte 1---------------------------------------------------------------- --&gt;

---
class: inverse, middle, center

# separate() e unite()

---

# Revisando tidy data

√â uma base que une os conceitos da estat√≠stica (amostra, vari√°vel) e da inform√°tica (linhas, colunas)

### As observa√ß√µes est√£o nas linhas

### As vari√°veis est√£o nas colunas

### Os valores est√£o nas c√©lulas

---

# Motiva√ß√£o

- Muitas vezes nossas c√©lulas n√£o s√£o valores.
- Podemos querer juntar as categorias de duas vari√°veis em uma s√≥.
- Ou ent√£o separar as categorias de uma vari√°vel em v√°rias.
- Para isso usamos `tidyr::separate()` e `tidyr::unite()`

---

# Nota√ß√£o

### `unite()`


```r
dados %&gt;% 
*  unite(coluna_nova, colunas, para, colar, sep = "separador")
```

### `separate()`



```r
dados %&gt;% 
*  separate(coluna_velha, c("colunas", "novas"), sep = "separador")
```

---
class: center

# Vamos ao R!

&lt;img src="img/03-dplyr-plus/gato.gif" width="80%" style="display: block; margin: auto;" /&gt;

&lt;!-- Parte 2---------------------------------------------------------------- --&gt;

---
class: inverse, middle, center

# Pivotagem

---

# Motiva√ß√£o

- Quando nossas linhas n√£o s√£o unidades obsevacionais ou nossas colunas n√£o s√£o vari√°veis, precisamos fazer pivotagem.
- √â similar √† pivotagem do Excel, mas mais completa.
- O ato de pivotar envolve "espalhar" ou "derreter" as informa√ß√µes de uma tabela.

---

# pivot_wider()


```r
knitr::include_graphics("img/03-dplyr-plus/wider.png")
```

&lt;img src="img/03-dplyr-plus/wider.png" width="90%" /&gt;

(retirado do livro [r4ds](https://r4ds.had.co.nz))

---

# pivot_longer()


```r
knitr::include_graphics("img/03-dplyr-plus/longer.png")
```

&lt;img src="img/03-dplyr-plus/longer.png" width="90%" /&gt;

(retirado do livro [r4ds](https://r4ds.had.co.nz))

---
class: center

# Vamos ao R!

&lt;img src="img/03-dplyr-plus/gato.gif" width="80%" style="display: block; margin: auto;" /&gt;

---

# Observa√ß√£o

- `pivot_longer()` e `pivot_wider()` s√£o novas vers√µes das fun√ß√µes `spread()` e `gather()`, respectivamente.
- As fun√ß√µes foram refatoradas por conta de reiteradas reclama√ß√µes da comunidade sobre a dificuldade de ensinar essas fun√ß√µes.
- No entanto, as fun√ß√µes antigas n√£o deixaram de existir. Elas s√≥ deixar√£o de ser atualizadas. Uma fun√ß√£o assim √© chamada de "aposentada" (ver ?spread).
- `pivot_longer()` e `pivot_wider()` ainda est√£o em desenvolvimento e podem mudar no futuro.

&lt;!-- Parte 3---------------------------------------------------------------- --&gt;

---
class: inverse, middle, center

# Pausa


---
class: inverse, middle, center

# Joins

---

# Motiva√ß√£o

- Join √© o que precisamos fazer quando temos duas tabela e precisamos pegar a informa√ß√£o de uma a partir das vari√°veis de outra.
- A teoria de joins √© completamente desenvolvida dentro da √°rea de banco de dados.
- Claro que `{dplyr}` n√£o poderia nos deixar na m√£o para isso üòÉ 
- Melhor material: [livro r4ds](https://r4ds.had.co.nz/relational-data.html)

---
class: center

# Vamos ao R!

&lt;img src="img/03-dplyr-plus/gato.gif" width="80%" style="display: block; margin: auto;" /&gt;

---

# Outros tipos de join

- `anti_join()`: mostra as linhas da base da esquerda que n√£o batem com a base da direita. √â √∫til para fazer de-paras. 
- `semi_join()`: √© parecido com `inner_join()`, mas n√£o copia as colunas da base da direita.

--

## Joins aproximados

- √â poss√≠vel fazer joins quando as vari√°veis n√£o batem exatamente, mas t√™m valores muito pr√≥ximos.
- Tamb√©m √© poss√≠vel fazer joins por similaridade de textos e at√© por express√µes regulares.
- D√™ uma olhada no pacote `{fuzzyjoin}`!

&lt;!-- Parte 4---------------------------------------------------------------- --&gt;

---
class: inverse, middle, center

# nest() / unnest()

---

# Motiva√ß√£o

- Nem sempre queremos trabalhar com valores nas c√©lulas
- √Äs vezes, pode ser √∫til guardar, em cada elemento, uma outra base de dados.
- Tabelas aninhadas podem facilitar visualiza√ß√£o e diminuem a quantidade de tabelas a serem consideradas no estudo.

--

- O tema √© pol√™mico e nem todos concordam...

---
class: center

# Vamos ao R!

&lt;img src="img/03-dplyr-plus/gato.gif" width="80%" style="display: block; margin: auto;" /&gt;

&lt;!-- Parte 5---------------------------------------------------------------- --&gt;

---
class: inverse, middle, center

# Programando com dplyr

---

# Motiva√ß√£o

- O `{dplyr}` facilita a nossa vida ao permitir colocar os nomes das vari√°veis sem aspas nos argumentos das fun√ß√µes principais.
- Isso s√≥ √© poss√≠vel por conta de um recurso quase exclusivo do R, chamado de *non standard evaluation* (NSE).
- No entanto, quando queremos criar fun√ß√µes, isso pode atrapalhar


```r
selecionar &lt;- function(da, coluna) {
  da %&gt;% 
    select(coluna)
}

da_sinesp_muni %&gt;% 
  selecionar(regiao)
```
    
    #&gt; Error: object 'regiao' not found

---

# Programando com R

- Para isso, existe o curly-curly `{{ }}`
- Basta coloc√°-lo ao redor do argumento que voc√™ quer passar


```r
selecionar &lt;- function(da, coluna) {
  da %&gt;% 
    select({{coluna}})
}

da_sinesp_muni %&gt;% 
  selecionar(regiao)
```

    # A tibble: 124,246 x 1
       regiao
       &lt;chr&gt; 
     1 NORTE 
     2 NORTE 
     3 NORTE 
     4 NORTE 
     5 NORTE 
     6 NORTE 
     7 NORTE 
     8 NORTE 
     9 NORTE 
    10 NORTE 
    # ‚Ä¶ with 124,236 more rows

---
class: center

# Vamos ao R!

&lt;img src="img/03-dplyr-plus/gato.gif" width="80%" style="display: block; margin: auto;" /&gt;

---

# Resumindo

- Use `{{variavel}}` quando n√£o quiser colocar aspas no argumento da fun√ß√£o.
- Use `.data[["variavel"]]` quando quiser colocar aspas no argumento da fun√ß√£o.
- Use `{{nome}} := ...` quando quiser criar colunas com nomes que est√£o no argumento da fun√ß√£o.

--

__Refer√™ncia__: https://www.curso-r.com/blog/2019-08-21-nse/
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "4:3"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
